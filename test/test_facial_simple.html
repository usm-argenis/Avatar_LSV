<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test - Animaci√≥n Facial Hola</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
            color: white;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        button {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
        }
        button:hover {
            background: #5568d3;
        }
        #progress {
            width: 300px;
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            overflow: hidden;
        }
        #progress-bar {
            height: 100%;
            background: #667eea;
            width: 0%;
            transition: width 0.1s;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>Test Animaci√≥n Facial - "hola"</h3>
        <div id="status">Cargando...</div>
        <div id="animations-info"></div>
    </div>

    <div id="controls">
        <button id="btn-play">‚ñ∂Ô∏è Reproducir</button>
        <button id="btn-pause">‚è∏Ô∏è Pausar</button>
        <button id="btn-reset">üîÑ Reiniciar</button>
        <div id="progress">
            <div id="progress-bar"></div>
        </div>
        <span id="time">0.0s / 0.0s</span>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Configuraci√≥n de Three.js
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 2);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        // Controles
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 1.4, 0);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Iluminaci√≥n
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        const fillLight = new THREE.DirectionalLight(0x88ccff, 0.3);
        fillLight.position.set(-5, 0, -5);
        scene.add(fillLight);

        // Variables globales
        let mixer = null;
        let model = null;
        let animationActions = [];
        let morphTargetMeshes = [];

        // Elementos UI
        const statusEl = document.getElementById('status');
        const animsInfoEl = document.getElementById('animations-info');
        const btnPlay = document.getElementById('btn-play');
        const btnPause = document.getElementById('btn-pause');
        const btnReset = document.getElementById('btn-reset');
        const progressBar = document.getElementById('progress-bar');
        const timeEl = document.getElementById('time');

        // Cargar GLB
        const loader = new GLTFLoader();
        statusEl.textContent = 'Cargando modelo...';

        loader.load(
            'output/glb/Duvall/saludos/Duvall_resultado_hola.glb',
            (gltf) => {
                model = gltf.scene;
                scene.add(model);

                // Buscar meshes con morph targets
                model.traverse((child) => {
                    if (child.isMesh && child.morphTargetInfluences) {
                        morphTargetMeshes.push(child);
                        console.log('Mesh con morph targets:', child.name, 
                                    'Targets:', child.morphTargetInfluences.length);
                    }
                });

                // Configurar animaciones
                if (gltf.animations && gltf.animations.length > 0) {
                    mixer = new THREE.AnimationMixer(model);
                    
                    let animInfo = '<br><strong>Animaciones encontradas:</strong><br>';
                    
                    gltf.animations.forEach((clip, index) => {
                        console.log(`Animaci√≥n ${index}:`, clip.name);
                        console.log('  Tracks:', clip.tracks.length);
                        
                        // Contar tracks de morphs
                        const morphTracks = clip.tracks.filter(t => t.name.includes('morphTargetInfluences'));
                        const boneTracks = clip.tracks.filter(t => !t.name.includes('morphTargetInfluences'));
                        
                        console.log('  Tracks de morphs:', morphTracks.length);
                        console.log('  Tracks de huesos:', boneTracks.length);
                        
                        // Mostrar primeros tracks de morphs
                        morphTracks.slice(0, 3).forEach(track => {
                            console.log('    Track morph:', track.name);
                        });
                        
                        const action = mixer.clipAction(clip);
                        animationActions.push(action);
                        
                        animInfo += `${index + 1}. ${clip.name} (${clip.duration.toFixed(2)}s)<br>`;
                        animInfo += `   - Tracks de huesos: ${boneTracks.length}<br>`;
                        animInfo += `   - Tracks de morphs: ${morphTracks.length}<br>`;
                    });
                    
                    animsInfoEl.innerHTML = animInfo;
                    animsInfoEl.innerHTML += `<br>Meshes con morphs: ${morphTargetMeshes.length}`;
                    
                    statusEl.textContent = '‚úÖ Modelo cargado';
                } else {
                    statusEl.textContent = '‚ö†Ô∏è No se encontraron animaciones';
                }
            },
            (progress) => {
                const percent = (progress.loaded / progress.total * 100).toFixed(0);
                statusEl.textContent = `Cargando... ${percent}%`;
            },
            (error) => {
                console.error('Error cargando GLB:', error);
                statusEl.textContent = '‚ùå Error al cargar';
            }
        );

        // Controles de reproducci√≥n
        btnPlay.addEventListener('click', () => {
            if (animationActions.length > 0) {
                animationActions.forEach(action => {
                    action.paused = false;
                    action.play();
                });
                statusEl.textContent = '‚ñ∂Ô∏è Reproduciendo';
            }
        });

        btnPause.addEventListener('click', () => {
            if (animationActions.length > 0) {
                animationActions.forEach(action => {
                    action.paused = true;
                });
                statusEl.textContent = '‚è∏Ô∏è Pausado';
            }
        });

        btnReset.addEventListener('click', () => {
            if (animationActions.length > 0) {
                animationActions.forEach(action => {
                    action.reset();
                    action.play();
                });
                statusEl.textContent = 'üîÑ Reiniciado';
            }
        });

        // Loop de animaci√≥n
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            if (mixer) {
                mixer.update(delta);
                
                // Actualizar UI de progreso
                if (animationActions.length > 0) {
                    const action = animationActions[0];
                    const duration = action.getClip().duration;
                    const currentTime = action.time;
                    const progress = (currentTime / duration) * 100;
                    
                    progressBar.style.width = `${progress}%`;
                    timeEl.textContent = `${currentTime.toFixed(1)}s / ${duration.toFixed(1)}s`;
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Debug: mostrar valores de morph targets cada segundo
        setInterval(() => {
            if (morphTargetMeshes.length > 0) {
                const head = morphTargetMeshes.find(m => m.name.includes('Wolf3D_Head'));
                if (head && head.morphTargetInfluences) {
                    // Buscar shape key mouthSmileLeft (√≠ndice puede variar)
                    const dict = head.morphTargetDictionary;
                    if (dict) {
                        const smileIndex = dict['mouthSmileLeft'];
                        if (smileIndex !== undefined) {
                            const value = head.morphTargetInfluences[smileIndex];
                            console.log('mouthSmileLeft:', value.toFixed(3));
                        }
                    }
                }
            }
        }, 1000);
    </script>
</body>
</html>
