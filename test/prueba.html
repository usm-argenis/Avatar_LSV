<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Visualizador LSV v3.2 - Multi Avatar</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* Panel de control principal - OCULTO */
        #main-panel {
            display: none; /* Completamente oculto */
        }

        #main-panel h2 {
            display: block; /* Mostrar t√≠tulo */
            color: white;
            font-size: 16px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(79, 195, 247, 0.3);
        }

        .control-group {
            display: block; /* Mostrar controles */
            margin-bottom: 10px;
        }

        .control-label {
            display: block; /* Mostrar etiquetas */
            color: #4fc3f7;
            font-size: 11px;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .selector-container {
            position: relative;
            display: block; /* Mostrar selectores */
        }

        select {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid #4fc3f7;
            padding: 8px 10px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            outline: none;
            transition: all 0.3s ease;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%234fc3f7' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            padding-right: 30px;
        }

        select:hover {
            border-color: #81d4fa;
            background-color: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(79, 195, 247, 0.3);
        }

        select:focus {
            border-color: #4fc3f7;
            box-shadow: 0 0 0 3px rgba(79, 195, 247, 0.2);
        }

        select option {
            background: #1a1a2e;
            color: white;
            padding: 10px;
        }

        #sign-select {
            border-color: #f093fb;
        }

        #sign-select:hover {
            border-color: #f5576c;
        }

        .info-display {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-row:last-child {
            border-bottom: none;
        }

        .info-row-label {
            color: #aaa;
            font-size: 13px;
        }

        .info-row-value {
            color: #4fc3f7;
            font-weight: bold;
            font-size: 14px;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-playing { background: #4caf50; box-shadow: 0 0 10px #4caf50; animation: pulse 1s infinite; }
        .status-paused { background: #ff9800; }
        .status-stopped { background: #f44336; }
        .status-loading { background: #2196f3; animation: pulse 0.5s infinite; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Controles de reproducci√≥n - HORIZONTALES ARRIBA */
        #playback-controls {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 12px 20px;
            border-radius: 15px;
            display: flex;
            flex-direction: row; /* HORIZONTAL */
            gap: 12px;
            align-items: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(15px);
            z-index: 100;
            border: 2px solid rgba(79, 195, 247, 0.2);
        }

        .playback-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .playback-btn:hover {
            transform: scale(1.15);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.6);
        }

        .playback-btn:active {
            transform: scale(0.95);
        }

        #play-pause {
            width: 45px;
            height: 45px;
            font-size: 18px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 4px 20px rgba(245, 87, 108, 0.5);
        }

        .speed-control {
            display: flex;
            flex-direction: row; /* HORIZONTAL */
            align-items: center;
            gap: 10px;
            color: white;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 25px;
        }

        .speed-control span:first-child {
            font-size: 16px;
        }

        #speed-value {
            font-size: 12px;
            color: #4fc3f7;
            font-weight: bold;
            min-width: 45px;
            text-align: center;
        }

        #speed-slider {
            width: 100px;
            height: 5px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
        }

        #speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #4fc3f7;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(79, 195, 247, 0.5);
        }

        #speed-value {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: #4fc3f7;
        }

        /* Timeline */
        #timeline-panel {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 70%;
            max-width: 600px;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px 18px;
            border-radius: 15px;
            box-shadow: 0 8px 35px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(15px);
            z-index: 100;
            border: 2px solid rgba(79, 195, 247, 0.2);
        }

        #timeline {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            outline: none;
            cursor: pointer;
        }

        #timeline::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            cursor: pointer;
            box-shadow: 0 3px 12px rgba(245, 87, 108, 0.6);
        }

        .timeline-info {
            display: flex;
            justify-content: space-between;
            color: white;
            font-size: 13px;
            margin-top: 12px;
            font-weight: 500;
        }

        /* Loading overlay */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            z-index: 200;
            background: rgba(0, 0, 0, 0.8);
            padding: 40px 60px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }

        .spinner {
            border: 5px solid rgba(255, 255, 255, 0.2);
            border-top: 5px solid #4fc3f7;
            border-radius: 50%;
            width: 70px;
            height: 70px;
            animation: spin 1s linear infinite;
            margin: 0 auto 25px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 20px;
            font-weight: 600;
            color: #4fc3f7;
        }

        .loading-subtext {
            font-size: 14px;
            color: #aaa;
            margin-top: 10px;
        }

        /* Error modal */
        .error-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.7);
            z-index: 1000;
            max-width: 600px;
            text-align: center;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }

        .error-modal h3 {
            margin-bottom: 20px;
            font-size: 28px;
        }

        .error-modal p {
            margin-bottom: 15px;
            font-size: 16px;
            line-height: 1.6;
        }

        .error-filename {
            font-weight: bold;
            color: #ffeb3b;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: monospace;
        }

        .error-causes {
            text-align: left;
            margin: 20px auto;
            max-width: 500px;
        }

        .error-causes li {
            margin: 10px 0;
            padding-left: 10px;
        }

        .error-btn {
            background: white;
            color: #dc3545;
            border: none;
            padding: 12px 35px;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            margin-top: 20px;
            transition: all 0.3s ease;
        }

        .error-btn:hover {
            background: #f8f9fa;
            transform: scale(1.05);
        }

        input[type="text"] {
            transition: all 0.3s ease;
        }

        input[type="text"]:focus {
            border-color: #81d4fa;
            box-shadow: 0 0 0 3px rgba(79, 195, 247, 0.2);
            background-color: rgba(255, 255, 255, 0.15);
        }

        input[type="text"]::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        #load-fbx-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.5);
        }

        #load-fbx-btn:active {
            transform: translateY(0);
        }

        /* Info badge */
        .info-badge {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px 20px;
            border-radius: 15px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
            z-index: 100;
            border: 2px solid rgba(79, 195, 247, 0.3);
            display: block; /* Mostrar badge */
        }

        .info-badge-icon {
            color: #4fc3f7;
            margin-right: 10px;
        }

        /* Campo de b√∫squeda de se√±as en la parte inferior */
        #sign-search-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 12px 25px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(15px);
            z-index: 100;
            border: 2px solid rgba(79, 195, 247, 0.3);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #sign-search-label {
            color: #4fc3f7;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .sign-search-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #sign-search-input {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            border: 2px solid #4fc3f7;
            padding: 12px 20px;
            border-radius: 15px;
            font-size: 18px;
            outline: none;
            transition: all 0.3s ease;
            text-align: center;
            width: 300px; /* M√°s ancho para escribir frases */
            font-weight: 600;
            -webkit-tap-highlight-color: transparent; /* Mejor para m√≥vil */
        }

        #sign-search-input:focus {
            border-color: #81d4fa;
            box-shadow: 0 0 0 3px rgba(79, 195, 247, 0.2);
            background: rgba(255, 255, 255, 0.15);
        }

        #sign-search-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        #sign-search-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            border: none;
            color: white;
            padding: 8px 20px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
        }

        #sign-search-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(245, 87, 108, 0.6);
        }

        #sign-search-btn:active {
            transform: translateY(0);
        }

        /* Panel de optimizaci√≥n */
        #optimization-panel {
            position: absolute;
            top: 150px;
            right: 20px;
            width: 350px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 8px 35px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(79, 195, 247, 0.2);
            z-index: 50;
            display: none; /* Oculto por defecto */
        }

        #optimization-panel.visible {
            display: block;
            animation: slideInRight 0.3s ease-out;
        }

        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(50px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .opt-header {
            color: #4fc3f7;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 2px solid rgba(79, 195, 247, 0.3);
        }

        .opt-field {
            margin-bottom: 12px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid #4fc3f7;
        }

        .opt-field strong {
            display: block;
            color: #4fc3f7;
            font-size: 11px;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .opt-field .value {
            color: white;
            font-size: 13px;
        }

        .coverage-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 12px;
        }

        .coverage-alta {
            background: #4caf50;
            color: white;
        }

        .coverage-media {
            background: #ff9800;
            color: white;
        }

        .coverage-baja {
            background: #f44336;
            color: white;
        }

        .word-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 6px;
        }

        .word-tag {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
        }

        .word-tag.disponible {
            background: #4caf50;
            color: white;
        }

        .word-tag.faltante {
            background: #f44336;
            color: white;
        }

        /* Toggle button para el panel */
        #toggle-opt {
            position: absolute;
            top: 150px;
            right: 20px;
            background: rgba(79, 195, 247, 0.2);
            border: 2px solid #4fc3f7;
            color: #4fc3f7;
            padding: 10px 15px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            z-index: 49;
            transition: all 0.3s ease;
        }

        #toggle-opt:hover {
            background: rgba(79, 195, 247, 0.3);
            transform: translateX(-5px);
        }

        /* Mostrar selector de avatares, ocultar otros elementos no necesarios */
        .info-display {
            display: none; /* Ocultar info en m√≥vil */
        }

        .selector-container {
            display: block; /* Mostrar selectores de avatar y se√±a */
        }

        #main-panel {
            display: block; /* Mostrar panel de control */
        }

        .info-badge {
            display: none; /* Ocultar badge en m√≥vil */
        }

        /* ===================================== */
        /* RESPONSIVE - MOBILE FIRST */
        /* ===================================== */
        
        @media (max-width: 768px) {
            /* Panel principal m√°s compacto */
            #main-panel {
                top: 10px;
                right: 10px;
                left: 10px;
                padding: 15px;
                min-width: auto;
                max-width: calc(100vw - 20px);
            }

            #main-panel h2 {
                font-size: 16px;
                margin-bottom: 12px;
                padding-bottom: 8px;
            }

            .control-group {
                margin-bottom: 12px;
            }

            .control-label {
                font-size: 10px;
                margin-bottom: 5px;
            }

            select {
                padding: 8px 10px;
                font-size: 13px;
                padding-right: 30px;
                background-position: right 10px center;
            }

            /* Controles de reproducci√≥n m√°s peque√±os - ARRIBA en m√≥vil tambi√©n */
            #playback-controls {
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                padding: 10px 15px;
                gap: 8px;
                border-radius: 40px;
            }

            .playback-btn {
                width: 35px;
                height: 35px;
                font-size: 14px;
            }

            #play-pause {
                width: 40px;
                height: 40px;
            }

            .playback-btn:hover {
                transform: scale(1.05);
            }
            
            /* Control de velocidad m√°s compacto en m√≥vil */
            .speed-control {
                padding: 6px 10px;
                gap: 6px;
            }
            
            .speed-control span:first-child {
                font-size: 14px;
            }
            
            #speed-slider {
                width: 60px;
            }
            
            #speed-value {
                font-size: 11px;
                min-width: 35px;
            }

            /* Info display compacto */
            .info-display {
                padding: 10px;
                margin-top: 12px;
            }

            .info-row {
                padding: 5px 0;
            }

            .info-row-label {
                font-size: 11px;
            }

            .info-row-value {
                font-size: 12px;
            }

            .status-indicator {
                width: 8px;
                height: 8px;
                margin-right: 5px;
            }

            /* Badge de nombre m√°s peque√±o */
            #avatar-name-badge {
                top: 10px;
                left: 10px;
                padding: 10px 15px;
                font-size: 14px;
                border-radius: 10px;
            }

            .info-badge-icon {
                margin-right: 6px;
            }

            /* Ocultar badge en pantallas muy peque√±as */
            @media (max-width: 480px) {
                #avatar-name-badge {
                    display: none;
                }

                #main-panel {
                    top: 5px;
                    right: 5px;
                    left: 5px;
                    padding: 10px;
                }

                #main-panel h2 {
                    font-size: 14px;
                }

                select {
                    padding: 6px 8px;
                    font-size: 12px;
                }

                #playback-controls {
                    top: 5px;
                    padding: 8px 12px;
                    gap: 8px;
                }

                .playback-btn {
                    width: 30px;
                    height: 30px;
                    font-size: 12px;
                }
                
                #play-pause {
                    width: 35px;
                    height: 35px;
                    font-size: 14px;
                }
                
                .speed-control {
                    padding: 5px 8px;
                    gap: 5px;
                }
                
                .speed-control span {
                    font-size: 12px;
                }
                
                #speed-slider {
                    width: 50px;
                }
                
                #speed-value {
                    font-size: 10px;
                    min-width: 30px;
                }
            }
        }

        /* Ajustes para tablets en horizontal */
        @media (min-width: 769px) and (max-width: 1024px) {
            #main-panel {
                top: 15px;
                right: 15px;
                padding: 20px;
                min-width: 280px;
            }

            #main-panel h2 {
                font-size: 18px;
            }

            #playback-controls {
                bottom: 20px;
                padding: 15px 25px;
            }

            .playback-btn {
                width: 45px;
                height: 45px;
                font-size: 18px;
            }
        }

        /* ===============================================
           ESTILOS PANEL DE ENTRENAMIENTO IA
           =============================================== */
        
        #toggle-training {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 50px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
            z-index: 1000;
        }

        #toggle-training:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 35px rgba(102, 126, 234, 0.6);
        }

        #training-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            width: 90%;
            max-width: 800px;
            max-height: 85vh;
            background: rgba(20, 20, 30, 0.98);
            border: 2px solid rgba(79, 195, 247, 0.3);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(20px);
            z-index: 2000;
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        #training-panel.active {
            opacity: 1;
            pointer-events: all;
            transform: translate(-50%, -50%) scale(1);
        }

        .training-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 20px;
            font-weight: bold;
            border-bottom: 2px solid rgba(79, 195, 247, 0.3);
        }

        .close-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        .training-tabs {
            display: flex;
            gap: 0;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px 15px;
            border-bottom: 1px solid rgba(79, 195, 247, 0.2);
        }

        .training-tab {
            flex: 1;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .training-tab:hover {
            background: rgba(79, 195, 247, 0.1);
            color: #4fc3f7;
        }

        .training-tab.active {
            background: linear-gradient(135deg, #4fc3f7 0%, #2196f3 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(79, 195, 247, 0.3);
        }

        .training-content {
            display: none;
            padding: 25px;
            overflow-y: auto;
            flex: 1;
        }

        .training-content.active {
            display: block;
        }

        /* TAB: Probar */
        .test-section {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .test-label {
            color: #4fc3f7;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            display: block;
        }

        #test-input {
            width: 100%;
            min-height: 100px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(79, 195, 247, 0.3);
            border-radius: 12px;
            padding: 15px;
            color: white;
            font-size: 16px;
            font-family: inherit;
            resize: vertical;
            outline: none;
            transition: all 0.3s ease;
        }

        #test-input:focus {
            border-color: #4fc3f7;
            box-shadow: 0 0 0 3px rgba(79, 195, 247, 0.1);
        }

        .action-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.4);
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(245, 87, 108, 0.6);
        }

        .action-btn:active {
            transform: translateY(0);
        }

        #test-result {
            background: rgba(79, 195, 247, 0.05);
            border: 2px solid rgba(79, 195, 247, 0.2);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
        }

        .result-field {
            margin-bottom: 20px;
        }

        .result-field:last-child {
            margin-bottom: 0;
        }

        .result-field strong {
            color: #4fc3f7;
            display: block;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .result-value {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px 15px;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            font-weight: 500;
        }

        .category-badge {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: bold;
        }

        .similarity-bar {
            position: relative;
            width: 100%;
            height: 30px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            overflow: hidden;
        }

        .similarity-fill {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(90deg, #4caf50 0%, #8bc34a 100%);
            transition: width 0.5s ease;
            border-radius: 15px;
        }

        .similarity-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 14px;
            z-index: 1;
        }

        .example-match {
            background: rgba(255, 255, 255, 0.03);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #4fc3f7;
        }

        .example-input {
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            margin-bottom: 8px;
        }

        .example-output {
            color: #4fc3f7;
            font-size: 16px;
            font-weight: bold;
        }

        /* TAB: Ejemplos */
        .filter-section {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .filter-label {
            color: #4fc3f7;
            font-size: 14px;
            font-weight: bold;
        }

        #category-filter {
            flex: 1;
            min-width: 200px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            border: 2px solid rgba(79, 195, 247, 0.3);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
            outline: none;
        }

        .example-count {
            color: rgba(255, 255, 255, 0.6);
            font-size: 13px;
            font-weight: bold;
        }

        .examples-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .example-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(79, 195, 247, 0.2);
            border-radius: 12px;
            padding: 15px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .example-card:hover {
            background: rgba(79, 195, 247, 0.1);
            border-color: #4fc3f7;
            transform: translateX(5px);
        }

        .example-card-input {
            color: white;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .example-card-output {
            color: #4fc3f7;
            font-size: 15px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .example-card-meta {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .example-card-category {
            background: rgba(102, 126, 234, 0.3);
            color: #4fc3f7;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
        }

        .example-card-cnm {
            background: rgba(245, 87, 108, 0.3);
            color: #f5576c;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
        }

        /* TAB: Estad√≠sticas */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(79, 195, 247, 0.2);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            border-color: #4fc3f7;
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(79, 195, 247, 0.2);
        }

        .stat-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .stat-value {
            color: #4fc3f7;
            font-size: 36px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            font-weight: 500;
        }

        .category-chart {
            background: rgba(255, 255, 255, 0.03);
            border: 2px solid rgba(79, 195, 247, 0.2);
            border-radius: 15px;
            padding: 25px;
        }

        .category-chart h3 {
            color: #4fc3f7;
            font-size: 18px;
            margin-bottom: 20px;
        }

        #category-bars {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .category-bar-item {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .category-bar-label {
            min-width: 150px;
            color: white;
            font-size: 13px;
            font-weight: 500;
        }

        .category-bar-container {
            flex: 1;
            height: 25px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        .category-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            transition: width 0.5s ease;
        }

        .category-bar-count {
            min-width: 40px;
            text-align: right;
            color: #4fc3f7;
            font-size: 14px;
            font-weight: bold;
        }

        /* Scrollbar personalizado */
        .training-content::-webkit-scrollbar,
        .examples-list::-webkit-scrollbar {
            width: 8px;
        }

        .training-content::-webkit-scrollbar-track,
        .examples-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }

        .training-content::-webkit-scrollbar-thumb,
        .examples-list::-webkit-scrollbar-thumb {
            background: rgba(79, 195, 247, 0.3);
            border-radius: 10px;
        }

        .training-content::-webkit-scrollbar-thumb:hover,
        .examples-list::-webkit-scrollbar-thumb:hover {
            background: rgba(79, 195, 247, 0.5);
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <!-- Loading overlay -->
    <div id="loading" style="display: none;">
        <div class="spinner"></div>
        <div class="loading-text">Cargando Modelo 3D...</div>
        <div class="loading-subtext" id="loading-subtext">Preparando animaci√≥n</div>
    </div>

    <!-- Info badge -->
    <div class="info-badge">
        <span class="info-badge-icon">ü§ü</span>
        <span id="current-animation">Visualizador LSV</span>
    </div>

    <!-- Panel de control principal -->
    <div id="main-panel">
        <h2>‚öôÔ∏è Control de Animaci√≥n</h2>
        
        <div class="control-group">
            <label class="control-label">üë§ Avatar</label>
            <div class="selector-container">
                <select id="avatar-select">
                    <option value="Duvall" selected>Duvall</option>
                    <option value="Luis">Luis</option>
                    <option value="Nancy">Nancy</option>
                    <option value="Nina">Nina</option>
                    <option value="Carla">Carla</option>
                    <option value="Argenis">Argenis</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">ü§ü Se√±a</label>
            <div class="selector-container">
                <select id="sign-select">
                    <option value="resultado_b">b</option>
                    <option value="resultado_c">c</option>
                    <option value="resultado_d">d</option>
                    <option value="resultado_e">e</option>
                </select>
            </div>
        </div>

        <div class="control-group">
            <label class="control-label">üîç B√∫squeda Directa FBX</label>
            <div style="display: flex; gap: 8px;">
                <input type="text" id="fbx-search" placeholder="Ej: avatar_nombre.fbx" 
                    style="flex: 1; background: rgba(255, 255, 255, 0.1); color: white; border: 2px solid #4fc3f7; padding: 12px 15px; border-radius: 10px; font-size: 14px; outline: none;">
                <button id="load-fbx-btn" title="Cargar FBX" 
                    style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border: none; color: white; padding: 12px 20px; border-radius: 10px; cursor: pointer; font-weight: bold; font-size: 14px;">
                    üìÇ Cargar
                </button>
            </div>
            <div style="font-size: 11px; color: #888; margin-top: 5px;">
                üí° Escribe el nombre completo del archivo en output/
            </div>
        </div>

        <div class="info-display">
            <div class="info-row">
                <span class="info-row-label">Estado:</span>
                <span class="info-row-value">
                    <span class="status-indicator status-stopped" id="status-dot"></span>
                    <span id="status-text">Detenido</span>
                </span>
            </div>
            <div class="info-row">
                <span class="info-row-label">Frames:</span>
                <span class="info-row-value">
                    <span id="current-frame">0</span> / <span id="total-frames">0</span>
                </span>
            </div>
            <div class="info-row">
                <span class="info-row-label">Duraci√≥n:</span>
                <span class="info-row-value" id="duration">0.0s</span>
            </div>
            <div class="info-row">
                <span class="info-row-label">Huesos:</span>
                <span class="info-row-value" id="bone-count">0</span>
            </div>
        </div>
    </div>

    <!-- Timeline -->
    <div id="timeline-panel">
        <input type="range" id="timeline" min="0" max="100" value="0" step="0.01">
        <div class="timeline-info">
            <span id="current-time">0:00.0</span>
            <span id="total-time">0:00.0</span>
        </div>
    </div>

    <!-- Controles de reproducci√≥n -->
    <div id="playback-controls">
        <button class="playback-btn" id="play-pause" title="Play/Pause">‚ñ∂Ô∏è</button>
        <button class="playback-btn" id="restart" title="Reiniciar">‚èÆ</button>
        <button class="playback-btn" id="stop" title="Detener">‚èπ</button>
        <button class="playback-btn" id="loop" title="Loop" style="opacity: 1;">üîÑ</button>
        <div class="speed-control">
            <span>‚ö°</span>
            <input type="range" id="speed-slider" min="0.25" max="2" value="1" step="0.25">
            <span id="speed-value">1.0x</span>
        </div>
    </div>

    <!-- Campo de b√∫squeda de se√±as -->
    <div id="sign-search-container">
        <label id="sign-search-label">ü§ü Ingresa la se√±a</label>
        <div class="sign-search-input-group">
            <input type="text" id="sign-search-input" placeholder="Ej: yo tu el, b c d..." maxlength="100">
            <button id="sign-search-btn">üîç Buscar</button>
        </div>
    </div>

    <!-- Panel de optimizaci√≥n de texto -->
    <button id="toggle-opt" style="display: none;">üìä Optimizaci√≥n</button>
    <div id="optimization-panel">
        <div class="opt-header">ü§ñ Optimizaci√≥n de Texto</div>
        
        <div class="opt-field">
            <strong>üìù Texto Original:</strong>
            <div class="value" id="opt-original">-</div>
        </div>

        <div class="opt-field">
            <strong>‚úÖ Texto Corregido:</strong>
            <div class="value" id="opt-corregido">-</div>
        </div>

        <div class="opt-field">
            <strong>üîÑ Orden LSV:</strong>
            <div class="value" id="opt-lsv">-</div>
        </div>

        <div class="opt-field">
            <strong>üìä Cobertura:</strong>
            <div class="value">
                <span id="opt-coverage" class="coverage-badge coverage-baja">0%</span>
            </div>
        </div>

        <div class="opt-field">
            <strong>‚úÖ Se√±as Disponibles:</strong>
            <div class="word-tags" id="opt-disponibles"></div>
        </div>

        <div class="opt-field">
            <strong>‚ùå Se√±as Faltantes:</strong>
            <div class="word-tags" id="opt-faltantes"></div>
        </div>
    </div>

    <!-- Panel de Entrenamiento IA -->
    <button id="toggle-training" title="Abrir Panel de Entrenamiento IA">üß† Entrenamiento IA</button>
    <div id="training-panel">
        <div class="training-header">
            <span>üß† Sistema de Entrenamiento LSV</span>
            <button id="close-training" class="close-btn">‚úñ</button>
        </div>
        
        <div class="training-tabs">
            <button class="training-tab active" data-tab="test">üî¨ Probar</button>
            <button class="training-tab" data-tab="examples">üìö Ejemplos</button>
            <button class="training-tab" data-tab="stats">üìä Estad√≠sticas</button>
        </div>

        <!-- TAB: Probar -->
        <div class="training-content active" id="tab-test">
            <div class="test-section">
                <label class="test-label">üìù Texto en Espa√±ol:</label>
                <textarea id="test-input" placeholder="Ejemplo: Me gradu√© hace 5 a√±os"></textarea>
                
                <button id="process-btn" class="action-btn">üöÄ Procesar con IA</button>
                
                <div id="test-result" style="display: none;">
                    <div class="result-field">
                        <strong>‚úÖ Estructura LSV:</strong>
                        <div class="result-value" id="result-lsv">-</div>
                    </div>
                    
                    <div class="result-field">
                        <strong>üè∑Ô∏è Categor√≠a:</strong>
                        <span class="category-badge" id="result-category">-</span>
                    </div>
                    
                    <div class="result-field">
                        <strong>üéØ Similitud:</strong>
                        <div class="similarity-bar">
                            <div class="similarity-fill" id="similarity-fill"></div>
                            <span class="similarity-text" id="similarity-text">0%</span>
                        </div>
                    </div>

                    <div class="result-field">
                        <strong>üí° Ejemplo Similar:</strong>
                        <div class="example-match" id="similar-example">
                            <div class="example-input">-</div>
                            <div class="example-output">-</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB: Ejemplos -->
        <div class="training-content" id="tab-examples">
            <div class="filter-section">
                <label class="filter-label">üîç Filtrar por Categor√≠a:</label>
                <select id="category-filter">
                    <option value="">Todas las categor√≠as</option>
                </select>
                <span class="example-count" id="example-count">0 ejemplos</span>
            </div>
            
            <div id="examples-list" class="examples-list"></div>
        </div>

        <!-- TAB: Estad√≠sticas -->
        <div class="training-content" id="tab-stats">
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-icon">üìö</div>
                    <div class="stat-value" id="total-examples">0</div>
                    <div class="stat-label">Total Ejemplos</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-icon">üè∑Ô∏è</div>
                    <div class="stat-value" id="total-categories">0</div>
                    <div class="stat-label">Categor√≠as</div>
                </div>
                
                <div class="stat-card">
                    <div class="stat-icon">üí¨</div>
                    <div class="stat-value" id="total-words">0</div>
                    <div class="stat-label">Palabras √önicas</div>
                </div>
            </div>
            
            <div class="category-chart">
                <h3>üìä Ejemplos por Categor√≠a</h3>
                <div id="category-bars"></div>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';

        // Variables globales
        let scene, camera, renderer, controls;
        let mixer, currentAction, clock;
        let currentModel = null;
        let currentAvatar = null; // Guardar qu√© avatar est√° cargado actualmente
        let selectedAvatar = 'Duvall'; // Avatar seleccionado desde la app m√≥vil (por defecto Duvall)
        let isPlaying = false;
        let isLooping = true;
        let animationSpeed = 0.6; // Velocidad m√°s lenta para ver mejor las se√±as
        
        // Pre-inicializar DRACOLoader para velocidad
        let dracoLoader = null;
        
        // Sistema de precarga y secuencias
        let modelsCache = {}; // Cache de modelos precargados
        let currentSequence = []; // Secuencia de se√±as a reproducir
        let currentSequenceIndex = 0; // √çndice actual en la secuencia
        let isPlayingSequence = false; // Si est√° reproduciendo una secuencia
        let sequenceTotalTime = 0; // Tiempo total acumulado de la secuencia
        let isLoadingFromTimeline = false; // Flag para evitar auto-play cuando se usa el timeline

        // Referencias a elementos del DOM (se inicializar√°n en init())
        let elements = {};

        // Construir ruta del GLB basado en avatar y se√±a espec√≠ficos
        // Busca en subcarpetas organizadas por categor√≠a
        async function buildModelPath(avatar, sign) {
            const categorias = [
                'dias_semana', 'tiempo', 'pronombres', 
                'saludos', 'cortesia', 'preguntas', 'expresiones'
            ];
            
            // NUEVA ESTRUCTURA: output/glb/{Genero}/{categoria}/{sign}.glb
            // Determinar g√©nero del avatar
            const genero = (avatar === 'Nancy' || avatar === 'Nina' || avatar === 'Carla') ? 'Mujer' : 'Hombre';
            
            console.log(`üîç Buscando se√±a: "${sign}" para avatar: "${avatar}" (${genero})`);
            
            // Buscar en cada categor√≠a dentro de la carpeta del g√©nero
            for (const categoria of categorias) {
                const categoryPath = `output/glb/${genero}/${categoria}/${sign}.glb`;
                try {
                    const response = await fetch(categoryPath, { method: 'HEAD' });
                    if (response.ok) {
                        // ‚ö° Solo log si NO estamos en secuencia
                        if (!isPlayingSequence) {
                            console.log(`‚úÖ Encontrado: ${categoryPath}`);
                        }
                        return categoryPath;
                    } else {
                        console.log(`‚ùå No encontrado en: ${categoryPath} (${response.status})`);
                    }
                } catch (e) {
                    console.log(`‚ùå Error buscando en: ${categoryPath} - ${e.message}`);
                }
            }
            
            // Si no se encontr√≥ en ninguna categor√≠a, devolver ruta por defecto (sin warning)
            const defaultPath = `output/glb/${genero}/saludos/${sign}.glb`;
            console.warn(`‚ö†Ô∏è Usando ruta por defecto: ${defaultPath}`);
            return defaultPath;
        }

        // Construir ruta del GLB basado en la entrada desde la app m√≥vil
        async function buildFBXPath(sign) {
            // Usar el avatar seleccionado desde la URL (configurado al inicio)
            const avatar = selectedAvatar;
            
            // Ruta relativa desde donde est√° el HTML (test/)
            return await buildModelPath(avatar, sign);
        }
        
        // Precargar solo los modelos espec√≠ficos que se necesitan
        async function preloadSpecificModels(signs) {
            const avatar = selectedAvatar; // Usar avatar desde variable global
            const modelsToLoad = [];
            
            // Filtrar solo los que NO est√°n en cache
            for (const sign of signs) {
                const cacheKey = `${avatar}_${sign}`;
                if (!modelsCache[cacheKey]) {
                    modelsToLoad.push(sign);
                }
            }
            
            if (modelsToLoad.length === 0) {
                console.log('‚ö° Todos los modelos ya est√°n en cache');
                return;
            }
            
            console.log('üöÄ PRECARGANDO MODELOS NECESARIOS:', modelsToLoad);
            elements.loading.style.display = 'block';
            elements.loadingSubtext.textContent = `‚ö° Preparando ${modelsToLoad.length} animaci√≥n(es)...`;
            
            const total = modelsToLoad.length;
            let loaded = 0;
            
            // ‚ö° OPTIMIZACI√ìN: Cargar todos en paralelo con Promise.all (ULTRA R√ÅPIDO)
            const startTime = performance.now();
            
            const loadPromises = modelsToLoad.map(async (sign) => {
                const path = await buildModelPath(avatar, sign);
                const cacheKey = `${avatar}_${sign}`;
                
                try {
                    const model = await loadModelAsync(path);
                    modelsCache[cacheKey] = model;
                    loaded++;
                    
                    // Actualizar progreso solo cada 20% para no ralentizar
                    if (loaded % Math.max(1, Math.floor(total / 5)) === 0 || loaded === total) {
                        const percent = ((loaded / total) * 100).toFixed(0);
                        elements.loadingSubtext.textContent = `‚ö° ${loaded}/${total} (${percent}%)`;
                    }
                    console.log(`‚úÖ [${loaded}/${total}]:`, cacheKey);
                    return true;
                } catch (error) {
                    console.warn(`‚ö†Ô∏è Error cargando ${cacheKey}:`, error.message);
                    return false;
                }
            });
            
            // Esperar a que terminen todas las cargas en paralelo
            await Promise.all(loadPromises);
            
            const loadTime = ((performance.now() - startTime) / 1000).toFixed(2);
            console.log(`‚ö° CARGA COMPLETADA en ${loadTime}s`);
            
            // ‚ö° Ocultar loading inmediatamente
            elements.loading.style.display = 'none';
            elements.loadingSubtext.textContent = '‚úÖ ¬°Listo!';
            
            console.log(`‚úÖ CARGA COMPLETADA: ${loaded} modelos en ${loadTime}s`);
        }
        
        // ‚ö° OPTIMIZACI√ìN: Cargar modelo con manager de carga √∫nica
        function loadModelAsync(path) {
            // Si ya se est√° cargando este modelo, retornar la promesa existente
            if (loadingPromises[path]) {
                console.log('‚è≥ Carga ya en progreso, reutilizando promesa:', path);
                return loadingPromises[path];
            }
            
            // Crear nueva promesa de carga
            const promise = new Promise((resolve, reject) => {
                const isGLB = path.toLowerCase().endsWith('.glb');
                
                if (isGLB) {
                    const loader = new GLTFLoader();
                    if (dracoLoader) {
                        loader.setDRACOLoader(dracoLoader);
                    }
                    
                    loader.load(
                        path,
                        (gltf) => {
                            // ‚ö° Optimizaci√≥n: Cachear geometr√≠as y materiales
                            gltf.scene.traverse((child) => {
                                if (child.isMesh) {
                                    if (!geometryCache[path]) geometryCache[path] = [];
                                    geometryCache[path].push(child.geometry);
                                    
                                    if (!materialCache[path]) materialCache[path] = [];
                                    materialCache[path].push(child.material);
                                }
                            });
                            
                            // ‚ö° Pre-compilar materiales para la GPU (evita lag en primera reproducci√≥n)
                            renderer.compile(gltf.scene, camera);
                            
                            resolve({ scene: gltf.scene, animations: gltf.animations });
                        },
                        undefined,
                        reject
                    );
                } else {
                    const loader = new FBXLoader();
                    loader.load(
                        path,
                        (fbx) => {
                            resolve({ scene: fbx, animations: fbx.animations });
                        },
                        undefined,
                        reject
                    );
                }
            });
            
            // Cachear la promesa para evitar cargas duplicadas
            loadingPromises[path] = promise;
            
            // Limpiar la promesa cuando termine (√©xito o error)
            promise.finally(() => {
                delete loadingPromises[path];
            });
            
            return promise;
        }
        
        // ================== OPTIMIZACI√ìN DE TEXTO ==================
        
        // Configuraci√≥n de la API
        const API_CONFIG = {
            baseUrl: 'http://192.168.86.27:5000',
            endpoints: {
                optimizar: '/api/optimizar',
                corregir: '/api/corregir',
                convertir: '/api/convertir-lsv',
                buscar: '/api/buscar-sena',
                senas: '/api/senas-disponibles'
            }
        };

        // Optimizar texto usando la API
        async function optimizarTexto(texto) {
            try {
                console.log('ü§ñ Optimizando texto:', texto);
                
                const response = await fetch(`${API_CONFIG.baseUrl}${API_CONFIG.endpoints.optimizar}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ texto: texto })
                });

                if (!response.ok) {
                    throw new Error(`Error HTTP: ${response.status}`);
                }

                const data = await response.json();
                console.log('‚úÖ Optimizaci√≥n exitosa:', data);
                
                // Mostrar resultados en el panel
                mostrarResultadosOptimizacion(data);
                
                return data;
                
            } catch (error) {
                console.warn('‚ö†Ô∏è Error en optimizaci√≥n, usando texto original:', error.message);
                
                // Si la API no est√° disponible, continuar con el texto original
                return {
                    texto_original: texto,
                    texto_corregido: texto,
                    texto_lsv: texto,
                    palabras_disponibles: texto.trim().toLowerCase().split(/\s+/),
                    palabras_faltantes: [],
                    porcentaje_cobertura: 100
                };
            }
        }

        // Mostrar resultados de optimizaci√≥n en el panel
        function mostrarResultadosOptimizacion(data) {
            const panel = document.getElementById('optimization-panel');
            const toggleBtn = document.getElementById('toggle-opt');
            
            // Actualizar campos
            document.getElementById('opt-original').textContent = data.texto_original || '-';
            document.getElementById('opt-corregido').textContent = data.texto_corregido || '-';
            document.getElementById('opt-lsv').textContent = data.texto_lsv || '-';
            
            // Actualizar cobertura con colores
            const coverage = data.porcentaje_cobertura || 0;
            const coverageBadge = document.getElementById('opt-coverage');
            coverageBadge.textContent = `${coverage}%`;
            
            // Cambiar color seg√∫n porcentaje
            coverageBadge.className = 'coverage-badge';
            if (coverage >= 70) {
                coverageBadge.classList.add('coverage-alta');
            } else if (coverage >= 30) {
                coverageBadge.classList.add('coverage-media');
            } else {
                coverageBadge.classList.add('coverage-baja');
            }
            
            // Palabras disponibles
            const disponiblesContainer = document.getElementById('opt-disponibles');
            disponiblesContainer.innerHTML = '';
            (data.palabras_disponibles || []).forEach(palabra => {
                const tag = document.createElement('span');
                tag.className = 'word-tag disponible';
                tag.textContent = palabra;
                disponiblesContainer.appendChild(tag);
            });
            
            // Palabras faltantes
            const faltantesContainer = document.getElementById('opt-faltantes');
            faltantesContainer.innerHTML = '';
            if (data.palabras_faltantes && data.palabras_faltantes.length > 0) {
                data.palabras_faltantes.forEach(palabra => {
                    const tag = document.createElement('span');
                    tag.className = 'word-tag faltante';
                    tag.textContent = palabra;
                    faltantesContainer.appendChild(tag);
                });
            } else {
                faltantesContainer.innerHTML = '<span style="color: #4caf50; font-size: 12px;">‚úÖ Todas las palabras disponibles</span>';
            }
            
            // Mostrar panel y bot√≥n toggle
            panel.classList.add('visible');
            toggleBtn.style.display = 'block';
            
            // Auto-ocultar despu√©s de 10 segundos
            setTimeout(() => {
                panel.classList.remove('visible');
            }, 10000);
        }

        // üöÄ SERVICE WORKER para cache persistente de modelos 3D
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/test/sw.js')
                    .then(registration => {
                        console.log('‚úÖ Service Worker registrado:', registration.scope);
                    })
                    .catch(error => {
                        console.warn('‚ö†Ô∏è Service Worker no disponible:', error);
                    });
            });
        }

        // Toggle del panel de optimizaci√≥n
        document.addEventListener('DOMContentLoaded', () => {
            const toggleBtn = document.getElementById('toggle-opt');
            const panel = document.getElementById('optimization-panel');
            
            if (toggleBtn && panel) {
                toggleBtn.addEventListener('click', () => {
                    panel.classList.toggle('visible');
                });
            }
        });
        
        // ================== FIN OPTIMIZACI√ìN ==================
        
        // Alias para compatibilidad - llama a la funci√≥n optimizarTexto
        const optimizarTextoAPI = optimizarTexto;
        
        // ‚ö° PRECARGA MASIVA: Cargar las se√±as m√°s comunes en segundo plano
        async function preloadCommonSigns() {
            const avatar = selectedAvatar;
            
            // Lista de las se√±as m√°s comunes (top 50)
            const commonSigns = [
                // Pronombres (muy comunes)
                'yo', 'tu', 'el', 'ella', 'nosotros', 'ustedes', 'ellos', 'ellas',
                // Saludos (muy comunes)
                'hola', 'adios', 'chao', 'buenos dias', 'buenas tardes', 'buenas noches',
                'como estas', 'que tal', 'mucho gusto', 'gracias', 'muchas gracias',
                'bienvenido', 'permiso', 'a la orden', 'buen provecho',
                // D√≠as de la semana
                'lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo',
                // Tiempo
                'hoy', 'ayer', 'ma√±ana', 'anteayer', 'pasado ma√±ana',
                'semana', 'mes', 'fin de semana', 'calendario',
                // Alfabeto m√°s usado
                'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
                'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
            ];
            
            console.log(`‚ö° Iniciando precarga masiva de ${commonSigns.length} se√±as comunes...`);
            
            // Cargar en lotes de 5 para no saturar
            const batchSize = 5;
            let loaded = 0;
            
            for (let i = 0; i < commonSigns.length; i += batchSize) {
                const batch = commonSigns.slice(i, i + batchSize);
                
                await Promise.all(batch.map(async (sign) => {
                    const cacheKey = `${avatar}_${sign}`;
                    
                    // Si ya est√° en cache, skip
                    if (modelsCache[cacheKey]) {
                        return;
                    }
                    
                    try {
                        const path = await buildModelPath(avatar, sign);
                        if (path) {
                            const modelData = await loadModelAsync(path);
                            if (modelData) {
                                modelsCache[cacheKey] = modelData;
                                loaded++;
                            }
                        }
                    } catch (error) {
                        // Silencioso - no importa si falla alguna
                    }
                }));
                
                // Peque√±a pausa entre lotes para no bloquear la UI
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            console.log(`‚úÖ Precarga masiva completada: ${loaded}/${commonSigns.length} se√±as en cache`);
        }
        
        // Procesar texto y crear secuencia de se√±as
        async function processTextSequence(text) {
            console.log('\nüé¨ ===== INICIANDO SECUENCIA =====');
            const sequenceStartTime = performance.now();
            
            // ü§ñ PASO 1: Optimizar el texto con IA
            const optimizacionResult = await optimizarTexto(text);
            
            // Usar el texto en orden LSV (Lengua de Se√±as Venezolana)
            const textoOptimizado = optimizacionResult.texto_lsv || text;
            console.log('üîÑ Texto original:', text);
            console.log('‚úÖ Texto optimizado (LSV):', textoOptimizado);
            
            // Dividir por espacios y filtrar vac√≠os
            const words = textoOptimizado.trim().toLowerCase().split(/\s+/).filter(w => w.length > 0);
            
            if (words.length === 0) {
                console.warn('‚ö†Ô∏è No hay palabras para procesar');
                return;
            }
            
            console.log(`üìù Procesando ${words.length} palabra(s):`, words);
            
            // ‚ö° PASO 2: Precargar TODO antes de reproducir
            console.log('‚ö° Precargando TODOS los modelos...');
            await preloadSpecificModels(words);
            
            const loadTime = ((performance.now() - sequenceStartTime) / 1000).toFixed(2);
            console.log(`‚úÖ Modelos listos en ${loadTime}s - Iniciando reproducci√≥n continua`);
            
            currentSequence = words;
            currentSequenceIndex = 0;
            isPlayingSequence = true;
            sequenceTotalTime = 0; // Resetear tiempo total al iniciar nueva secuencia
            
            // Calcular duraci√≥n total de la secuencia
            const avatar = selectedAvatar; // Usar avatar desde variable global
            let totalDuration = 0;
            for (const word of words) {
                const cacheKey = `${avatar}_${word}`;
                const cachedData = modelsCache[cacheKey];
                if (cachedData && cachedData.animations && cachedData.animations.length > 0) {
                    totalDuration += cachedData.animations[0].duration;
                }
            }
            
            // Configurar el timeline con la duraci√≥n total
            elements.timeline.max = totalDuration;
            elements.totalTime.textContent = formatTime(totalDuration);
            console.log('‚è±Ô∏è Duraci√≥n total de la secuencia:', totalDuration.toFixed(2), 's');
            
            // Iniciar reproducci√≥n de la secuencia
            playNextInSequence();
        }
        
        // Reproducir siguiente se√±a en la secuencia
        async function playNextInSequence() {
            console.log(`üîç playNextInSequence llamado - √≠ndice: ${currentSequenceIndex}, total: ${currentSequence.length}, isPlaying: ${isPlayingSequence}`);
            
            if (!isPlayingSequence || currentSequenceIndex >= currentSequence.length) {
                console.log('‚úÖ Secuencia completada - Total de animaciones reproducidas:', currentSequenceIndex);
                console.log('‚è±Ô∏è Tiempo total de la secuencia:', sequenceTotalTime.toFixed(2), 's');
                isPlayingSequence = false;
                // No resetear sequenceTotalTime aqu√≠ para que se vea el tiempo total acumulado
                return;
            }
            
            const sign = currentSequence[currentSequenceIndex];
            const avatar = selectedAvatar; // Usar avatar desde variable global
            const cacheKey = `${avatar}_${sign}`;
            
            console.log(`üé¨ Reproduciendo [${currentSequenceIndex + 1}/${currentSequence.length}]:`, sign, '| cacheKey:', cacheKey);
            
            // Verificar si est√° en cache
            if (modelsCache[cacheKey]) {
                console.log('‚ö° Cargando desde cache:', cacheKey);
                displayModelFromCache(cacheKey, sign);
            } else {
                console.warn('‚ö†Ô∏è Modelo no encontrado en cache:', cacheKey);
                // Cargar din√°micamente si no est√° en cache
                const path = await buildModelPath(avatar, sign);
                loadFBX(path);
            }
        }
        
        // Mostrar modelo desde el cache
        function displayModelFromCache(cacheKey, sign) {
            const cachedData = modelsCache[cacheKey];
            if (!cachedData) {
                console.error('‚ùå Modelo no encontrado en cache:', cacheKey);
                return;
            }
            
            const avatar = selectedAvatar;
            
            // ‚ö° Clonar el modelo PRIMERO (necesario para animaciones independientes)
            const clonedScene = SkeletonUtils.clone(cachedData.scene);
            const clonedAnimations = cachedData.animations.map(clip => clip.clone());
            
            elements.currentAnimation.textContent = `${avatar} - ${sign}`;
            
            // ‚ö° Procesar el nuevo modelo y SOLO DESPU√âS limpiar el anterior
            buildModelPath(avatar, sign).then(path => {
                onFBXLoaded(clonedScene, path, new Set(), clonedAnimations);
            });
        }
        
        // Limpiar el modelo actual de la escena
        function cleanupCurrentModel() {
            // ‚ö° Limpieza completa y r√°pida
            if (currentAction) {
                currentAction.stop();
                currentAction.enabled = false;
                currentAction = null;
            }
            
            if (mixer) {
                mixer.stopAllAction();
                // Remover todos los listeners
                mixer.removeEventListener('finished', onSequenceAnimationFinished);
                // Liberar cache del root
                const root = mixer.getRoot();
                if (root) mixer.uncacheRoot(root);
                mixer = null;
            }
            
            if (currentModel && currentModel.parent === scene) {
                scene.remove(currentModel);
            }
            currentModel = null;
        }
        
        // Evento cuando termina una animaci√≥n de la secuencia
        function onSequenceAnimationFinished(event) {
            console.log(`üéØ Animaci√≥n terminada - Siguiente inmediato`);            
            if (isPlayingSequence) {
                // Guardar duraci√≥n antes de limpiar
                if (currentAction) {
                    const clipDuration = currentAction.getClip().duration;
                    sequenceTotalTime += clipDuration;
                }
                
                // Remover el listener para evitar duplicados
                if (mixer) {
                    mixer.removeEventListener('finished', onSequenceAnimationFinished);
                }
                
                currentSequenceIndex++;
                
                // Transici√≥n instant√°nea - sin delay
                playNextInSequence();
            }
        }

        // Funci√≥n eliminada - no se necesita b√∫squeda directa desde el visualizador

        // Inicializar escena
        function init() {
            try {
                console.log('üöÄ Iniciando aplicaci√≥n...');
                
                // Inicializar referencias a elementos del DOM
                elements = {
                    loading: document.getElementById('loading'),
                    loadingSubtext: document.getElementById('loading-subtext'),
                    statusDot: document.getElementById('status-dot'),
                    statusText: document.getElementById('status-text'),
                    currentAnimation: document.getElementById('current-animation'),
                    currentFrame: document.getElementById('current-frame'),
                    totalFrames: document.getElementById('total-frames'),
                    duration: document.getElementById('duration'),
                    boneCount: document.getElementById('bone-count'),
                    currentTime: document.getElementById('current-time'),
                    totalTime: document.getElementById('total-time'),
                    timeline: document.getElementById('timeline'),
                    playPause: document.getElementById('play-pause'),
                    stop: document.getElementById('stop'),
                    restart: document.getElementById('restart'),
                    loop: document.getElementById('loop'),
                    speedSlider: document.getElementById('speed-slider'),
                    speedValue: document.getElementById('speed-value')
                };
                
                // Verificar que todos los elementos existen
                const missingElements = Object.entries(elements).filter(([key, el]) => !el);
                if (missingElements.length > 0) {
                    console.error('‚ùå Elementos del DOM faltantes:', missingElements.map(([k]) => k));
                    throw new Error('Faltan elementos del DOM');
                }
                
                console.log('‚úÖ Elementos del DOM inicializados');
                
                // PRE-CARGAR Draco decoder (CR√çTICO para velocidad)
                dracoLoader = new DRACOLoader();
                dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
                dracoLoader.setDecoderConfig({ type: 'js' });
                dracoLoader.preload(); // ‚ö° Descarga los decodificadores AHORA
                console.log('‚ö° Pre-cargando decodificadores Draco...');
            
            // Escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2B3E50); // Azul medio oscuro

            // C√°mara
            camera = new THREE.PerspectiveCamera(
                50,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1.5, 4);

            // Renderer - Optimizado para velocidad y calidad
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance", // ‚ö° Forzar GPU de alto rendimiento
                alpha: false, // ‚ö° Sin canal alpha para mejor rendimiento
                premultipliedAlpha: false // ‚ö° Evitar problemas de transparencia
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap; // ‚ö° Sombras m√°s r√°pidas (no PCFSoft)
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            renderer.sortObjects = true; // ‚ö° Ordenar objetos para evitar problemas de transparencia
            document.getElementById('container').appendChild(renderer.domElement);

            // Controles
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1, 0);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 2;
            controls.maxDistance = 15;
            controls.maxPolarAngle = Math.PI / 1.5;

            // Iluminaci√≥n mejorada
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
            mainLight.position.set(3, 6, 4);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 1024; // ‚ö° Reducido de 2048 para velocidad
            mainLight.shadow.mapSize.height = 1024;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 50;
            scene.add(mainLight);

            const fillLight = new THREE.DirectionalLight(0x6699ff, 0.4);
            fillLight.position.set(-3, 3, -4);
            scene.add(fillLight);

            const backLight = new THREE.DirectionalLight(0xffaa66, 0.6);
            backLight.position.set(0, 2, -5);
            scene.add(backLight);

            // Grid y ejes
            const gridHelper = new THREE.GridHelper(10, 20, 0x34495E, 0x5D6D7E); // Azul gris√°ceo
            scene.add(gridHelper);

            const axesHelper = new THREE.AxesHelper(3);
            scene.add(axesHelper);

            // Clock
            clock = new THREE.Clock();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            elements.playPause.addEventListener('click', togglePlayPause);
            elements.stop.addEventListener('click', stopAnimation);
            elements.restart.addEventListener('click', restartAnimation);
            elements.loop.addEventListener('click', toggleLoop);
            elements.timeline.addEventListener('input', onTimelineChange);
            elements.speedSlider.addEventListener('input', onSpeedChange);
            
            // Event listeners para campo de b√∫squeda de texto
            const signSearchInput = document.getElementById('sign-search-input');
            const signSearchBtn = document.getElementById('sign-search-btn');
            
            if (signSearchBtn) {
                signSearchBtn.addEventListener('click', () => {
                    const text = signSearchInput.value.trim();
                    if (text) {
                        processTextSequence(text);
                    }
                });
            }
            
            if (signSearchInput) {
                signSearchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const text = signSearchInput.value.trim();
                        if (text) {
                            processTextSequence(text);
                        }
                    }
                });
            }

            // Leer par√°metros de URL
            const urlParams = new URLSearchParams(window.location.search);
            const wordParam = urlParams.get('word');
            const autoloadParam = urlParams.get('autoload');
            const avatarParam = urlParams.get('avatar'); // Leer par√°metro de avatar
            
            // Configurar avatar si viene por URL (desde la app m√≥vil)
            if (avatarParam) {
                selectedAvatar = avatarParam; // Asignar directamente (ya viene capitalizado)
                console.log('üë§ Avatar configurado desde app m√≥vil:', selectedAvatar);
            } else {
                // Valor por defecto si no viene desde la app
                selectedAvatar = 'Duvall';
                console.log('üë§ Avatar por defecto:', selectedAvatar);
            }
            
            // NO cargar ning√∫n modelo al inicio, dejar la escena vac√≠a
            console.log('‚úÖ Escena lista - esperando entrada desde app m√≥vil');
            elements.currentAnimation.textContent = `üì± Avatar: ${selectedAvatar} - Escribe una se√±a`;
            updateStatus('stopped', 'Listo');
            
            // ‚ö° PRECARGA MASIVA: Cargar las se√±as m√°s comunes en segundo plano
            preloadCommonSigns();
            
            // Si viene una palabra por URL, procesarla como secuencia
            if (wordParam) {
                const signSearchInput = document.getElementById('sign-search-input');
                if (signSearchInput) {
                    signSearchInput.value = wordParam; // Mostrar en el campo de texto
                }
                console.log('üì± Palabra recibida desde app m√≥vil:', wordParam);
                console.log('üë§ Avatar activo:', selectedAvatar);
                if (autoloadParam === 'true') {
                    // Precargar y reproducir secuencia
                    processTextSequence(wordParam);
                }
            }

            // Iniciar animaci√≥n
            animate();
                
            console.log('‚úÖ Aplicaci√≥n inicializada correctamente');
            } catch (error) {
                console.error('‚ùå Error fatal al inicializar:', error);
                alert('Error al inicializar el visualizador 3D. Revisa la consola para m√°s detalles.');
            }
        }

        // Funci√≥n eliminada - la selecci√≥n viene desde la app m√≥vil via URL

        // Funci√≥n eliminada - no hay b√∫squeda manual, todo viene desde la app

        function loadFBX(path) {
            // Detectar si es GLB o FBX
            const isGLB = path.toLowerCase().endsWith('.glb');
            console.log(`üîÑ Cargando ${isGLB ? 'GLB' : 'FBX'}:`, path);
            
            // ‚ö° Solo mostrar loading si NO estamos en secuencia (transiciones instant√°neas)
            if (!isPlayingSequence) {
                elements.loading.style.display = 'block';
                elements.loadingSubtext.textContent = 'Cargando ' + path.split('/').pop();
                updateStatus('loading', 'Cargando...');
            }

            // NO limpiar aqu√≠ - mantener modelo anterior visible hasta que el nuevo est√© listo
            // cleanupCurrentModel(); // Se mover√° a onFBXLoaded

            isPlaying = false;
            elements.playPause.textContent = '‚ñ∂Ô∏è';

            // Usar LoadingManager para detectar texturas faltantes y aplicar fallback
            const missingTextures = new Set();
            const manager = new THREE.LoadingManager();
            
            manager.onError = function (url) {
                console.warn('‚ö†Ô∏è Texture failed to load (404):', url);
                missingTextures.add(url);
            };

            manager.onLoad = function () {
                console.log('‚úÖ LoadingManager: All resources loaded');
            };

            if (isGLB) {
                // Cargar GLB con soporte para Draco
                const loader = new GLTFLoader(manager);
                
                // ‚ö° Usar el DRACOLoader pre-inicializado (mucho m√°s r√°pido)
                if (dracoLoader) {
                    loader.setDRACOLoader(dracoLoader);
                } else {
                    // Fallback si por alguna raz√≥n no se inicializ√≥
                    const tempDracoLoader = new DRACOLoader();
                    tempDracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
                    tempDracoLoader.setDecoderConfig({ type: 'js' });
                    loader.setDRACOLoader(tempDracoLoader);
                }
                
                loader.load(
                    path,
                    (gltf) => {
                        // ‚ö° Procesamiento inmediato (sin timeout)
                        console.log('üé® Texturas faltantes detectadas:', missingTextures.size);
                        onFBXLoaded(gltf.scene, path, missingTextures, gltf.animations);
                    },
                    (xhr) => {
                        const percent = (xhr.loaded / xhr.total * 100).toFixed(1);
                        elements.loadingSubtext.textContent = `Cargando... ${percent}%`;
                        console.log(`üìä Progreso: ${percent}%`);
                    },
                    (error) => onFBXError(error, path)
                );
            } else {
                // Cargar FBX
                const loader = new FBXLoader(manager);
                loader.load(
                    path,
                    (fbx) => {
                        // ‚ö° Procesamiento inmediato (sin timeout)
                        console.log('üé® Texturas faltantes detectadas:', missingTextures.size);
                        onFBXLoaded(fbx, path, missingTextures);
                    },
                    (xhr) => {
                        const percent = (xhr.loaded / xhr.total * 100).toFixed(1);
                        elements.loadingSubtext.textContent = `Cargando... ${percent}%`;
                        console.log(`üìä Progreso: ${percent}%`);
                    },
                    (error) => onFBXError(error, path)
                );
            }
        }

        function onFBXLoaded(fbx, path, missingTextures, animations = null) {
            // ‚ö° Limpiar el modelo anterior JUSTO ANTES de mostrar el nuevo (transici√≥n suave)
            cleanupCurrentModel();
            
            // ‚ö° Solo ocultar loading si NO estamos en secuencia (para que sea m√°s r√°pido)
            if (!isPlayingSequence) {
                elements.loading.style.display = 'none';
                console.log('‚úÖ Modelo cargado exitosamente');
            }
            
            currentModel = fbx;

            // Detectar propiedades desde el path
            const isLeonard = path.includes('Leonard');
            const isJH = path.includes('JH');
            const hasTextures = path.includes('con_materiales');
            const isGLB = path.toLowerCase().endsWith('.glb');
            
            // Determinar nombre del avatar desde el path o usar el seleccionado
            let avatarName = selectedAvatar || 'Duvall'; // Por defecto
            if (isLeonard) avatarName = 'Leonard';
            else if (isJH) avatarName = hasTextures ? 'JH_con_materiales' : 'JH';
            
            // ‚ö° Reducir logs en secuencias para mayor velocidad
            if (!isPlayingSequence) {
                console.log('üë§ Avatar:', avatarName, '| Formato:', isGLB ? 'GLB' : 'FBX');
            }

            // Los archivos GLB vienen en escala 1.0, los FBX necesitan 0.01
            let scale = isGLB ? 1.0 : 0.01;

            // IMPORTANTE: Resetear la escala antes de aplicar nueva
            fbx.scale.set(scale, scale, scale);            // Centrar modelo
            fbx.updateMatrixWorld(true);
            const box = new THREE.Box3().setFromObject(fbx);
            const center = box.getCenter(new THREE.Vector3());

            // Resetear posici√≥n antes de centrar
            fbx.position.set(-center.x, -box.min.y, -center.z);

            // Configurar materiales
            let meshCount = 0;
            fbx.traverse((child) => {
                if (child.isMesh) {
                    meshCount++;
                    child.castShadow = true;
                    child.receiveShadow = true;

                    // Material mejorado
                    if (child.material) {
                        const name = child.name.toLowerCase();

                        // SIEMPRE imprimir nombre del mesh para debugging
                        console.log('üîç MESH ENCONTRADO:', child.name, '| Avatar:', avatarName);

                        // Para Leonard y JH (sin texturas): aplicar colores procedurales
                        // JH_con_materiales tiene texturas, no aplicar colores
                        if ((avatarName === 'Leonard' || avatarName === 'JH') && avatarName !== 'JH_con_materiales') {
                            // Quitar referencias a texturas faltantes
                            if (child.material.map) {
                                console.log('üóëÔ∏è Removiendo textura de:', child.name);
                                child.material.map = null;
                            }
                            
                            console.log('üîç Procesando mesh:', child.name);
                            
                            // Para JH: un solo mesh con m√∫ltiples materiales
                            if (avatarName === 'JH') {
                                // JH puede tener array de materiales o material √∫nico
                                const materials = Array.isArray(child.material) ? child.material : [child.material];
                                
                                materials.forEach((mat, idx) => {
                                    if (!mat) return;
                                    
                                    // Remover texturas faltantes
                                    if (mat.map) mat.map = null;
                                    
                                    const matName = mat.name ? mat.name.toLowerCase() : '';
                                    console.log(`üé® Material [${idx}]:`, mat.name);
                                    
                                    // Asignar colores seg√∫n nombre del material
                                    if (matName.includes('eyelash')) {
                                        mat.color.set(0x0D0D0D); // pesta√±as negras
                                        console.log('  üëÅÔ∏è Color: Pesta√±as negras');
                                    } else if (matName.includes('body1')) {
                                        mat.color.set(0x4A5F8C); // ropa azul
                                        console.log('  üëï Color: Ropa azul');
                                    } else if (matName.includes('body')) {
                                        mat.color.set(0xF2C2A5); // piel
                                        console.log('  üë§ Color: Piel');
                                    } else {
                                        mat.color.set(0xFF00FF); // magenta para debug
                                        console.warn('  ‚ö†Ô∏è Material NO reconocido');
                                    }
                                    
                                    mat.roughness = 0.3;
                                    mat.metalness = 0.0;
                                    mat.needsUpdate = true;
                                });
                            } else {
                                // Para Leonard: aplicar colores por nombre de mesh
                                if (name.includes('body')) {
                                    child.material.color.set(0xF2C2A5); // piel
                                    console.log('üë§ Piel aplicada a BODY:', child.name);
                                } else if (name.includes('sweater')) {
                                    child.material.color.set(0x263A66); // su√©ter azul
                                    console.log('üëï Su√©ter aplicado:', child.name);
                                } else if (name.includes('collar')) {
                                    child.material.color.set(0x263A66); // collar del su√©ter
                                    console.log('üëî Collar aplicado:', child.name);
                                } else if (name.includes('pants')) {
                                    child.material.color.set(0x4D4D59); // pantalones grises
                                    console.log('üëñ Pantalones aplicados:', child.name);
                                } else if (name.includes('hair')) {
                                    child.material.color.set(0x402619); // cabello casta√±o
                                    console.log('üíá Cabello aplicado:', child.name);
                                } else if (name.includes('eyelash')) {
                                    child.material.color.set(0x0D0D0D); // pesta√±as negras
                                    console.log('üëÅÔ∏è Pesta√±as aplicadas:', child.name);
                                } else if (name.includes('shoes')) {
                                    child.material.color.set(0x1A1A1A); // zapatos negros
                                    console.log('üëû Zapatos aplicados:', child.name);
                                } else {
                                    // Si no coincide, aplicar color llamativo para debugging
                                    child.material.color.set(0xFF00FF); // MAGENTA para detectar
                                    console.warn('‚ö†Ô∏è Mesh NO reconocido (MAGENTA):', child.name);
                                }
                            }
                        } else {
                            // Arreglar materiales con texturas
                            if (child.material.map) {
                                // Configurar texturas correctamente
                                child.material.map.wrapS = THREE.ClampToEdgeWrapping;
                                child.material.map.wrapT = THREE.ClampToEdgeWrapping;
                                child.material.map.anisotropy = renderer.capabilities.getMaxAnisotropy();
                                child.material.map.needsUpdate = true;
                                console.log('‚úÖ Textura configurada para:', child.name);
                            } else {
                                // Sin textura: usar color base
                                console.log('‚ö†Ô∏è Mesh sin textura:', child.name);
                                const isBodyPart = name.includes('body') ||
                                                   name.includes('skin') ||
                                                   name.includes('face') ||
                                                   name.includes('head') ||
                                                   name.includes('arm') ||
                                                   name.includes('hand') ||
                                                   name.includes('neck');
                                if (!isBodyPart) {
                                    // Si no es parte del cuerpo y no tiene textura, usar color
                                    if (!child.material.color || child.material.color.r < 0.1) {
                                        child.material.color = new THREE.Color(0x888888);
                                    }
                                } else {
                                    // Partes del cuerpo sin textura: color piel
                                    child.material.color = new THREE.Color(0xF2C2A5);
                                }
                            }
                            
                            // ‚ö° CORRECCI√ìN: Asegurar opacidad completa (sin transparencia)
                            child.material.transparent = false;
                            child.material.opacity = 1.0;
                            child.material.alphaTest = 0;
                            child.material.depthWrite = true;
                            child.material.depthTest = true;
                        }

                        // Ajustar propiedades del material seg√∫n avatar
                        if (avatarName === 'Leonard' || avatarName === 'JH') {
                            // Sin texturas: necesita menos roughness para reflejar m√°s luz
                            if (!Array.isArray(child.material)) {
                                child.material.roughness = 0.3;
                                child.material.metalness = 0.0;
                            }
                        } else {
                            // Remy y Carlos con texturas
                            child.material.roughness = 0.7;
                            child.material.metalness = 0.0;
                            
                            // Asegurar que use colores de v√©rtices si los tiene
                            if (child.geometry && child.geometry.attributes.color) {
                                child.material.vertexColors = true;
                                console.log('‚úÖ Usando vertex colors para:', child.name);
                            }
                        }
                        
                        // ‚ö° CORRECCI√ìN: Configuraci√≥n com√∫n anti-transparencia
                        child.material.side = THREE.FrontSide;
                        child.material.flatShading = false;
                        child.material.depthWrite = true; // ‚ö° Escritura de profundidad
                        child.material.depthTest = true;  // ‚ö° Test de profundidad
                        child.material.transparent = false; // ‚ö° NO transparente
                        child.material.opacity = 1.0; // ‚ö° Opacidad completa
                        child.material.needsUpdate = true;
                    }
                }
            });

            // ‚ö° CR√çTICO: Asegurar que el modelo est√° completamente procesado ANTES de agregarlo
            fbx.updateMatrixWorld(true);
            
            // ‚ö° Forzar actualizaci√≥n de todas las geometr√≠as
            fbx.traverse((child) => {
                if (child.isMesh) {
                    if (child.geometry) {
                        child.geometry.computeBoundingBox();
                        child.geometry.computeBoundingSphere();
                    }
                }
            });
            
            scene.add(fbx);
            
            // ‚ö° Forzar renderizado inmediato para evitar lag visual (solo si renderer est√° listo)
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }

            // Ajustar exposici√≥n para avatares sin texturas (necesitan MUCHA m√°s luz)
            // JH_con_materiales tiene texturas, no necesita exposici√≥n alta
            if ((avatarName === 'Leonard' || avatarName === 'JH') && avatarName !== 'JH_con_materiales') {
                renderer.toneMappingExposure = 3.5;
                console.log('üí° Exposici√≥n aumentada para ' + avatarName + ':', 3.5);
            } else {
                renderer.toneMappingExposure = 1.2;
                console.log('üí° Exposici√≥n normal:', 1.2);
            }

            // Contar huesos
            let boneCount = 0;
            fbx.traverse((child) => {
                if (child.isBone) boneCount++;
            });
            elements.boneCount.textContent = boneCount;
            console.log('ü¶¥ Huesos:', boneCount);
            console.log('üé® Meshes:', meshCount);

            // Configurar animaci√≥n
            // Si animations viene como par√°metro (GLB), usarlo; sino usar fbx.animations (FBX)
            const modelAnimations = animations || fbx.animations;
            console.log('üé¨ Animaciones encontradas:', modelAnimations.length);

            if (modelAnimations.length > 0) {
                mixer = new THREE.AnimationMixer(fbx);
                const clip = modelAnimations[0];
                currentAction = mixer.clipAction(clip);
                currentAction.timeScale = animationSpeed;
                
                // Si est√° en secuencia, reproducir solo una vez
                if (isPlayingSequence) {
                    currentAction.setLoop(THREE.LoopOnce, 1);
                    currentAction.clampWhenFinished = true;
                } else {
                    currentAction.setLoop(isLooping ? THREE.LoopRepeat : THREE.LoopOnce);
                    currentAction.clampWhenFinished = true;
                }

                const fps = 30;
                const totalFrames = Math.round(clip.duration * fps);
                elements.totalFrames.textContent = totalFrames;

                const minutes = Math.floor(clip.duration / 60);
                const seconds = (clip.duration % 60).toFixed(1);
                elements.duration.textContent = `${minutes}:${seconds.padStart(4, '0')}s`;
                
                // NO actualizar totalTime ni timeline.max si es parte de una secuencia
                // porque ya se configur√≥ con la duraci√≥n total
                if (!isPlayingSequence) {
                    elements.totalTime.textContent = formatTime(clip.duration);
                    elements.timeline.max = clip.duration;
                }

                console.log('‚è±Ô∏è Duraci√≥n:', clip.duration, 'Frames:', totalFrames);

                // NO auto-reproducir el modelo inicial, dejarlo en pausa
                // Solo auto-reproducir si es parte de una secuencia Y NO viene del timeline
                if (isPlayingSequence && !isLoadingFromTimeline) {
                    // ‚ö° CR√çTICO: Resetear completamente la animaci√≥n
                    currentAction.reset();
                    currentAction.time = 0;
                    currentAction.setEffectiveWeight(1.0); // Peso completo desde el inicio
                    currentAction.enabled = true;
                    
                    // ‚ö° Resetear el clock para evitar saltos en el primer frame
                    clock.getDelta(); // Consumir delta acumulado
                    
                    // ‚ö° Reproducir inmediatamente (el loop de animate() manejar√° mixer.update)
                    currentAction.play();
                    
                    isPlaying = true;
                    elements.playPause.textContent = '‚è∏';
                    updateStatus('playing', 'Reproduciendo');
                    
                    // Configurar evento para pasar a la siguiente se√±a cuando termine
                    mixer.addEventListener('finished', onSequenceAnimationFinished);
                } else if (isLoadingFromTimeline) {
                    // Cuando viene del timeline, preparar pero NO auto-reproducir
                    // El requestAnimationFrame en onTimelineChange manejar√° el estado
                    currentAction.time = 0;
                    currentAction.paused = true;
                    currentAction.stop(); // Asegurar que est√° detenida
                    console.log('üïí Cargado desde timeline - esperando configuraci√≥n...');
                } else {
                    // Modelo inicial en pausa - renderizar pose inicial
                    currentAction.reset();
                    currentAction.time = 0;
                    currentAction.paused = true;
                    currentAction.stop();
                    
                    isPlaying = false;
                    elements.playPause.textContent = '‚ñ∂Ô∏è';
                    updateStatus('paused', 'Listo para reproducir');
                }
            } else {
                console.warn('‚ö†Ô∏è No hay animaciones');
                elements.totalFrames.textContent = '0';
                elements.duration.textContent = '0.0s';
                updateStatus('stopped', 'Sin animaci√≥n');
            }

            // Ajustar c√°mara (reutilizar box ya calculado arriba)
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraDistance = maxDim / (2 * Math.tan(fov / 2));
            cameraDistance *= 1.8;

            camera.position.set(0, size.y * 0.6, cameraDistance);
            camera.lookAt(new THREE.Vector3(0, size.y * 0.5, 0));
            controls.target.set(0, size.y * 0.5, 0);
            controls.update();
        }

        function onFBXError(error, path) {
            console.error('‚ùå Error cargando modelo:', error);
            elements.loading.style.display = 'none';
            updateStatus('stopped', 'Error');

            // Solo mostrar modal de error si NO estamos en secuencia (evitar spam)
            if (isPlayingSequence) {
                console.warn('‚ö†Ô∏è Error en secuencia, continuando...');
                return;
            }

            const errorModal = document.createElement('div');
            errorModal.className = 'error-modal';
            errorModal.innerHTML = `
                <h3>‚ùå Error de Carga</h3>
                <p>No se pudo cargar el archivo FBX:</p>
                <div class="error-filename">${path}</div>
                <p style="font-size: 14px; color: #ffcccc;">Detalles del error:</p>
                <div class="error-filename" style="font-size: 13px;">${error.message || 'Error desconocido'}</div>
                <p style="font-size: 15px; margin-top: 20px;">Posibles causas:</p>
                <ul class="error-causes">
                    <li>‚úó El archivo no existe en la ruta especificada</li>
                    <li>‚úó El servidor web no est√° corriendo<br><code style="background: rgba(0,0,0,0.3); padding: 5px; border-radius: 5px;">python -m http.server 8000</code></li>
                    <li>‚úó El archivo FBX est√° corrupto</li>
                    <li>‚úó Problema de permisos de acceso</li>
                </ul>
                <button class="error-btn" onclick="this.parentElement.remove()">Cerrar</button>
            `;

            document.body.appendChild(errorModal);

            setTimeout(() => {
                if (errorModal.parentElement) {
                    errorModal.remove();
                }
            }, 15000);
        }

        function togglePlayPause() {
            if (!currentAction) return;

            if (isPlaying) {
                currentAction.paused = true;
                isPlaying = false;
                elements.playPause.textContent = '‚ñ∂Ô∏è';
                updateStatus('paused', 'Pausado');
            } else {
                currentAction.paused = false;
                currentAction.play();
                isPlaying = true;
                elements.playPause.textContent = '‚è∏';
                updateStatus('playing', 'Reproduciendo');
            }
        }

        function stopAnimation() {
            if (!currentAction) return;

            currentAction.stop();
            isPlaying = false;
            elements.playPause.textContent = '‚ñ∂Ô∏è';
            updateStatus('stopped', 'Detenido');
            elements.timeline.value = 0;
            elements.currentTime.textContent = '0:00.0';
            elements.currentFrame.textContent = '0';
        }

        function restartAnimation() {
            if (!currentAction) return;

            currentAction.reset();
            currentAction.play();
            isPlaying = true;
            elements.playPause.textContent = '‚è∏';
            updateStatus('playing', 'Reproduciendo');
        }

        function toggleLoop() {
            isLooping = !isLooping;
            if (currentAction) {
                currentAction.setLoop(isLooping ? THREE.LoopRepeat : THREE.LoopOnce);
            }
            elements.loop.style.opacity = isLooping ? '1' : '0.4';
            console.log('üîÑ Loop:', isLooping ? 'ON' : 'OFF');
        }

        function onTimelineChange(event) {
            const requestedTime = parseFloat(event.target.value);
            
            // Si no hay secuencia cargada, comportamiento normal
            if (currentSequence.length === 0) {
                if (!currentAction) return;
                currentAction.time = requestedTime;
                mixer.update(0);
                return;
            }
            
            // Para secuencias: calcular qu√© modelo deber√≠a estar visible
            const avatar = selectedAvatar; // Usar avatar desde variable global
            let accumulatedTime = 0;
            let targetModelIndex = -1;
            let timeInModel = 0;
            let timeBeforeTarget = 0;
            
            // Encontrar el modelo correcto seg√∫n el tiempo solicitado
            for (let i = 0; i < currentSequence.length; i++) {
                const word = currentSequence[i];
                const cacheKey = `${avatar}_${word}`;
                const cachedData = modelsCache[cacheKey];
                
                if (cachedData && cachedData.animations && cachedData.animations.length > 0) {
                    const duration = cachedData.animations[0].duration;
                    
                    if (requestedTime >= accumulatedTime && requestedTime < accumulatedTime + duration) {
                        // Este es el modelo correcto
                        targetModelIndex = i;
                        timeInModel = requestedTime - accumulatedTime;
                        timeBeforeTarget = accumulatedTime;
                        break;
                    }
                    
                    accumulatedTime += duration;
                }
            }
            
            // Si el tiempo est√° m√°s all√° del √∫ltimo modelo, usar el √∫ltimo
            if (targetModelIndex === -1 && currentSequence.length > 0) {
                targetModelIndex = currentSequence.length - 1;
                const lastWord = currentSequence[targetModelIndex];
                const lastCacheKey = `${avatar}_${lastWord}`;
                const lastCached = modelsCache[lastCacheKey];
                
                if (lastCached && lastCached.animations && lastCached.animations.length > 0) {
                    const lastDuration = lastCached.animations[0].duration;
                    timeBeforeTarget = accumulatedTime - lastDuration;
                    timeInModel = Math.min(requestedTime - timeBeforeTarget, lastDuration);
                }
            }
            
            // Si es el mismo modelo, solo ajustar el tiempo (scrubbing dentro del mismo modelo)
            if (targetModelIndex === currentSequenceIndex && currentAction) {
                currentAction.time = timeInModel;
                mixer.update(0);
                return;
            }
            
            // Necesitamos cambiar de modelo (usuario se movi√≥ fuera del rango del modelo actual)
            if (targetModelIndex !== -1 && targetModelIndex !== currentSequenceIndex) {
                console.log(`‚è™ Saltando a [${targetModelIndex + 1}/${currentSequence.length}] tiempo=${timeInModel.toFixed(2)}s`);
                
                // Guardar el estado de reproducci√≥n
                const wasPlaying = isPlaying;
                
                // Detener reproducci√≥n temporalmente
                if (currentAction) {
                    currentAction.stop();
                }
                isPlaying = false;
                
                // Actualizar variables ANTES de cargar
                currentSequenceIndex = targetModelIndex;
                sequenceTotalTime = timeBeforeTarget;
                isLoadingFromTimeline = true; // ACTIVAR FLAG
                
                const sign = currentSequence[targetModelIndex];
                const cacheKey = `${avatar}_${sign}`;
                
                // Cargar modelo
                displayModelFromCache(cacheKey, sign);
                
                // Esperar un frame para que el modelo se cargue
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => { // Doble RAF para asegurar que el modelo est√° cargado
                        if (currentAction) {
                            currentAction.time = timeInModel;
                            currentAction.paused = !wasPlaying;
                            mixer.update(0);
                            
                            if (wasPlaying) {
                                currentAction.play();
                                isPlaying = true;
                                elements.playPause.textContent = '‚è∏';
                            } else {
                                isPlaying = false;
                                elements.playPause.textContent = '‚ñ∂Ô∏è';
                            }
                            
                            isLoadingFromTimeline = false; // DESACTIVAR FLAG
                            console.log('‚úÖ Timeline ajustado - paused:', currentAction.paused, 'isPlaying:', isPlaying);
                        }
                    });
                });
            }
        }

        function onSpeedChange(event) {
            animationSpeed = parseFloat(event.target.value);
            elements.speedValue.textContent = `${animationSpeed.toFixed(2)}x`;

            if (currentAction) {
                currentAction.timeScale = animationSpeed;
            }
        }

        function updateStatus(status, text) {
            elements.statusDot.className = `status-indicator status-${status}`;
            elements.statusText.textContent = text;
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = (seconds % 60).toFixed(1);
            return `${mins}:${secs.padStart(4, '0')}`;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (mixer && isPlaying) {
                // Actualizar mixer con el tiempo delta
                mixer.update(delta);
                
                // Calcular tiempo actual considerando la acumulaci√≥n de secuencias
                const currentAnimTime = currentAction ? currentAction.time : 0;
                const totalElapsedTime = sequenceTotalTime + currentAnimTime;

                if (currentAction) {
                    const time = currentAction.time;
                    // Mostrar SIEMPRE el tiempo acumulado total de la secuencia
                    const displayTime = sequenceTotalTime + time;
                    
                    // Debug: Mostrar valores cada segundo
                    if (Math.floor(displayTime) !== Math.floor(displayTime - delta)) {
                        console.log('üïê Display:', displayTime.toFixed(2), 's = sequenceTotalTime:', sequenceTotalTime.toFixed(2), 's + time:', time.toFixed(2), 's | isPlaying:', isPlaying, '| paused:', currentAction.paused, '| weight:', currentAction.weight);
                    }
                    
                    elements.timeline.value = displayTime;
                    elements.currentTime.textContent = formatTime(displayTime);

                    const fps = 30;
                    const currentFrame = Math.round(displayTime * fps);
                    elements.currentFrame.textContent = currentFrame;
                }
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Iniciar aplicaci√≥n cuando el DOM est√© listo
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>

    <!-- Script para Panel de Entrenamiento IA -->
    <script>
        // ===============================================
        // SISTEMA DE ENTRENAMIENTO LSV - FRONTEND
        // ===============================================

        const API_BASE_URL = 'http://192.168.86.27:5000/api';
        let trainingData = {
            ejemplos: [],
            categorias: [],
            stats: {}
        };

        // Inicializar panel de entrenamiento
        document.addEventListener('DOMContentLoaded', () => {
            initTrainingPanel();
            loadTrainingData();
        });

        function initTrainingPanel() {
            // Referencias DOM
            const toggleBtn = document.getElementById('toggle-training');
            const trainingPanel = document.getElementById('training-panel');
            const closeBtn = document.getElementById('close-training');
            const tabs = document.querySelectorAll('.training-tab');
            const processBtn = document.getElementById('process-btn');
            const categoryFilter = document.getElementById('category-filter');

            // Toggle panel
            toggleBtn.addEventListener('click', () => {
                trainingPanel.classList.add('active');
            });

            closeBtn.addEventListener('click', () => {
                trainingPanel.classList.remove('active');
            });

            // Cerrar con ESC
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && trainingPanel.classList.contains('active')) {
                    trainingPanel.classList.remove('active');
                }
            });

            // Cambiar entre tabs
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabName = tab.dataset.tab;
                    switchTab(tabName);
                });
            });

            // Procesar texto con IA
            processBtn.addEventListener('click', () => {
                processTextWithAI();
            });

            // Filtrar ejemplos por categor√≠a
            categoryFilter.addEventListener('change', (e) => {
                filterExamplesByCategory(e.target.value);
            });
        }

        function switchTab(tabName) {
            // Desactivar todas las tabs
            document.querySelectorAll('.training-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.training-content').forEach(c => c.classList.remove('active'));

            // Activar tab seleccionada
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            document.getElementById(`tab-${tabName}`).classList.add('active');

            // Cargar contenido seg√∫n la tab
            if (tabName === 'examples') {
                renderExamples();
            } else if (tabName === 'stats') {
                renderStats();
            }
        }

        async function loadTrainingData() {
            try {
                // Cargar ejemplos
                const ejemplosRes = await fetch(`${API_BASE_URL}/ejemplos`);
                if (ejemplosRes.ok) {
                    trainingData.ejemplos = await ejemplosRes.json();
                }

                // Cargar categor√≠as
                const categoriasRes = await fetch(`${API_BASE_URL}/categorias`);
                if (categoriasRes.ok) {
                    trainingData.categorias = await categoriasRes.json();
                    populateCategoryFilter();
                }

                console.log('‚úÖ Datos de entrenamiento cargados:', trainingData.ejemplos.length, 'ejemplos');
            } catch (error) {
                console.error('‚ùå Error cargando datos de entrenamiento:', error);
                // Usar datos de respaldo si el backend no est√° disponible
                useBackupData();
            }
        }

        function useBackupData() {
            // Datos de respaldo si el backend no responde
            trainingData.ejemplos = [
                {"input": "Mi profesi√≥n es ingeniero", "output": "MI PROFESI√ìN INGENIERO", "categoria": "profesion"},
                {"input": "Me gradu√© hace 5 a√±os", "output": "YO GRADUAR 5 A√ëOS ATR√ÅS", "categoria": "tiempo_pasado"},
                {"input": "¬øQu√© hora es?", "output": "HORA QU√â", "categoria": "pregunta", "cnm": "pregunta"}
            ];
            trainingData.categorias = ['profesion', 'tiempo_pasado', 'pregunta'];
            populateCategoryFilter();
        }

        function populateCategoryFilter() {
            const filter = document.getElementById('category-filter');
            filter.innerHTML = '<option value="">Todas las categor√≠as</option>';
            
            trainingData.categorias.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat;
                option.textContent = cat.replace(/_/g, ' ').toUpperCase();
                filter.appendChild(option);
            });
        }

        async function processTextWithAI() {
            const input = document.getElementById('test-input').value.trim();
            
            if (!input) {
                alert('‚ö†Ô∏è Por favor ingresa un texto en espa√±ol');
                return;
            }

            const processBtn = document.getElementById('process-btn');
            processBtn.disabled = true;
            processBtn.textContent = '‚è≥ Procesando...';

            try {
                const response = await fetch(`${API_BASE_URL}/procesar`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ texto: input })
                });

                if (response.ok) {
                    const result = await response.json();
                    displayProcessResult(result);
                } else {
                    throw new Error('Error en el servidor');
                }
            } catch (error) {
                console.error('‚ùå Error procesando texto:', error);
                alert('‚ùå Error conectando con el servidor. Aseg√∫rate de que el backend est√© activo.');
            } finally {
                processBtn.disabled = false;
                processBtn.textContent = 'üöÄ Procesar con IA';
            }
        }

        function displayProcessResult(result) {
            const resultDiv = document.getElementById('test-result');
            resultDiv.style.display = 'block';

            // Estructura LSV
            document.getElementById('result-lsv').textContent = result.lsv_optimizado || result.output || '-';

            // Categor√≠a
            const categoryBadge = document.getElementById('result-category');
            categoryBadge.textContent = result.categoria || 'general';

            // Similitud
            const similarity = result.similitud || 0;
            document.getElementById('similarity-fill').style.width = `${similarity}%`;
            document.getElementById('similarity-text').textContent = `${similarity}%`;

            // Ejemplo similar
            if (result.ejemplo_similar) {
                const inputDiv = document.querySelector('.example-input');
                const outputDiv = document.querySelector('.example-output');
                inputDiv.textContent = `üìù ${result.ejemplo_similar.input}`;
                outputDiv.textContent = `‚úÖ ${result.ejemplo_similar.output}`;
            }
        }

        function filterExamplesByCategory(categoria) {
            const filtered = categoria 
                ? trainingData.ejemplos.filter(e => e.categoria === categoria)
                : trainingData.ejemplos;

            document.getElementById('example-count').textContent = `${filtered.length} ejemplos`;
            renderExamplesList(filtered);
        }

        function renderExamples() {
            renderExamplesList(trainingData.ejemplos);
            document.getElementById('example-count').textContent = `${trainingData.ejemplos.length} ejemplos`;
        }

        function renderExamplesList(ejemplos) {
            const container = document.getElementById('examples-list');
            container.innerHTML = '';

            if (ejemplos.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: rgba(255,255,255,0.5); padding: 40px;">No hay ejemplos disponibles</div>';
                return;
            }

            ejemplos.forEach(ejemplo => {
                const card = document.createElement('div');
                card.className = 'example-card';
                
                const input = document.createElement('div');
                input.className = 'example-card-input';
                input.textContent = `üìù ${ejemplo.input}`;
                
                const output = document.createElement('div');
                output.className = 'example-card-output';
                output.textContent = `‚úÖ ${ejemplo.output}`;
                
                const meta = document.createElement('div');
                meta.className = 'example-card-meta';
                
                if (ejemplo.categoria) {
                    const catBadge = document.createElement('span');
                    catBadge.className = 'example-card-category';
                    catBadge.textContent = ejemplo.categoria.replace(/_/g, ' ');
                    meta.appendChild(catBadge);
                }
                
                if (ejemplo.cnm) {
                    const cnmBadge = document.createElement('span');
                    cnmBadge.className = 'example-card-cnm';
                    cnmBadge.textContent = `CNM: ${ejemplo.cnm}`;
                    meta.appendChild(cnmBadge);
                }
                
                card.appendChild(input);
                card.appendChild(output);
                card.appendChild(meta);
                
                // Click para copiar al campo de prueba
                card.addEventListener('click', () => {
                    document.getElementById('test-input').value = ejemplo.input;
                    switchTab('test');
                });
                
                container.appendChild(card);
            });
        }

        function renderStats() {
            const totalExamples = trainingData.ejemplos.length;
            const totalCategories = trainingData.categorias.length;
            
            // Contar palabras √∫nicas
            const uniqueWords = new Set();
            trainingData.ejemplos.forEach(e => {
                e.output.split(' ').forEach(word => uniqueWords.add(word));
            });
            
            document.getElementById('total-examples').textContent = totalExamples;
            document.getElementById('total-categories').textContent = totalCategories;
            document.getElementById('total-words').textContent = uniqueWords.size;

            // Gr√°fico de categor√≠as
            renderCategoryChart();
        }

        function renderCategoryChart() {
            const container = document.getElementById('category-bars');
            container.innerHTML = '';

            // Contar ejemplos por categor√≠a
            const categoryCounts = {};
            trainingData.ejemplos.forEach(e => {
                const cat = e.categoria || 'sin_categoria';
                categoryCounts[cat] = (categoryCounts[cat] || 0) + 1;
            });

            // Encontrar m√°ximo para porcentajes
            const maxCount = Math.max(...Object.values(categoryCounts));

            // Ordenar por cantidad
            const sortedCategories = Object.entries(categoryCounts)
                .sort((a, b) => b[1] - a[1]);

            sortedCategories.forEach(([categoria, count]) => {
                const item = document.createElement('div');
                item.className = 'category-bar-item';

                const label = document.createElement('div');
                label.className = 'category-bar-label';
                label.textContent = categoria.replace(/_/g, ' ');

                const barContainer = document.createElement('div');
                barContainer.className = 'category-bar-container';

                const barFill = document.createElement('div');
                barFill.className = 'category-bar-fill';
                const percentage = (count / maxCount) * 100;
                barFill.style.width = `${percentage}%`;

                const countLabel = document.createElement('div');
                countLabel.className = 'category-bar-count';
                countLabel.textContent = count;

                barContainer.appendChild(barFill);
                item.appendChild(label);
                item.appendChild(barContainer);
                item.appendChild(countLabel);
                container.appendChild(item);
            });
        }
    </script>
</body>
</html>

