<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>LSV Mobile - Animaciones</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #ffffff;
            overflow: hidden;
            color: white;
        }

        #app {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #viewer-container {
            flex: 1;
            position: relative;
            background: linear-gradient(180deg, #1a1a2e 0%, #2d2d44 100%);
        }

        #canvas-3d {
            width: 100%;
            height: 100%;
        }

        .status {
            position: absolute;
            top: 15px;
            left: 15px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.95) 0%, rgba(118, 75, 162, 0.95) 100%);
            padding: 10px 18px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            z-index: 50;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.2);
            min-width: 120px;
            text-align: center;
        }
        
        .status.loading {
            background: linear-gradient(135deg, rgba(245, 147, 251, 0.95) 0%, rgba(102, 126, 234, 0.95) 100%);
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.95; }
            50% { opacity: 1; }
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #loading.hidden {
            display: none;
        }

        .spinner {
            width: 70px;
            height: 70px;
            border: 5px solid rgba(255, 255, 255, 0.2);
            border-top: 5px solid #f093fb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 25px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 20px;
            color: #f093fb;
            font-weight: 600;
        }

        /* Barra superior de controles */
      .top-bar {
            position: absolute;
            top: 15px;
            /* --- CAMBIOS PARA CENTRAR --- */
            left: 50%;
            transform: translateX(-50%);
            /* ---------------------------- */
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            z-index: 100;
            width: max-content; /* Asegura que la barra no se estire de m√°s */
        }

        .control-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 2px solid rgba(255, 255, 255, 0.4);
            color: white;
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 10px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 3px;
            min-width: 70px;
            height: auto;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .control-btn .btn-icon {
            font-size: 18px;
            line-height: 1;
        }

        .control-btn .btn-text {
            font-size: 9px;
            line-height: 1;
            margin-top: 2px;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .control-btn:active {
            transform: translateY(0) scale(0.95);
        }

        .control-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        /* Bot√≥n Pausar - Verde cuando puede pausar */
        .control-btn.pause {
            background: linear-gradient(135deg, #4CAF50 0%, #45A049 100%);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        }

        .control-btn.pause:hover {
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
        }

        /* Bot√≥n Pausar cuando est√° pausado - Rojo */
        .control-btn.pause.paused {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.4);
        }

        .control-btn.pause.paused:hover {
            box-shadow: 0 6px 20px rgba(244, 67, 54, 0.6);
        }

        /* Bot√≥n Repetir - Azul */
        .control-btn.replay {
            background: linear-gradient(135deg, #2196F3 0%, #53a5f8 100%);
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.4);
        }

        .control-btn.replay:hover {
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.6);
        }

        /* Bot√≥n Reset C√°mara - Morado */
        .control-btn.reset-camera {
            background: linear-gradient(135deg, #ff3300 0%, #ff3838cb 100%);
            box-shadow: 0 4px 15px rgba(255, 81, 0, 0.4);
        }

        .control-btn.reset-camera:hover {
            box-shadow: 0 6px 20px rgba(156, 39, 176, 0.6);
        }

        /* Input de texto inferior */
        .input-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            /*background: linear-gradient(180deg, rgba(26, 26, 46, 0.98) 0%, rgba(0, 0, 0, 0.98) 100%);
            */padding: 15px;
            padding-bottom: max(15px, env(safe-area-inset-bottom));
            display: flex;
            gap: 12px;
            align-items: center;
            z-index: 100;
            /*//box-shadow: 0 -4px 20px rgba(102, 126, 234, 0.3);
            border-top: 3px solid rgba(102, 126, 234, 0.5);*/
            min-height: 70px;
        }

        .text-input {
            flex: 1;
            background: linear-gradient(180deg, rgba(46, 46, 73, 0.98) 0%, rgb(34, 42, 54) 100%);
            
            border: 2px solid rgba(102, 126, 234, 0.5);
            border-radius: 25px;
            color: white;
            padding: 14px 20px;
            font-size: 16px;
            font-weight: 500;
            outline: none;
            transition: all 0.3s ease;
            box-shadow: inset 0 2px 8px rgba(0, 60, 255, 0.253);
            min-height: 48px;
        }

        .text-input:focus {
            border-color: #667eea;
            background: linear-gradient(180deg, rgba(46, 46, 73, 0.98) 0%, rgb(34, 42, 54) 100%);
            box-shadow: inset 0 2px 8px rgba(0, 60, 255, 0.253), 0 0 0 3px rgba(102, 126, 234, 0.3);
        }

        .text-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
            font-weight: 400;
        }

        .animate-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 2px solid rgba(255, 255, 255, 0.4);
            color: white;
            padding: 14px 24px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5);
            min-width: 110px;
            min-height: 48px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .animate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.7);
        }

        .animate-btn:active {
            transform: translateY(0) scale(0.97);
        }

        .animate-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="viewer-container">
            <canvas id="canvas-3d"></canvas>
            
            <!-- Status -->
            
            <!-- Botones superiores derechos -->
            <div class="top-bar">
                <button class="control-btn reset-camera" id="resetCameraBtn" title="Resetear C√°mara">
                    <span class="btn-icon">üéØ</span>
                    <span class="btn-text">Resetear</span>
                </button>
                <button class="control-btn pause" id="pauseBtn" disabled title="Pausar/Reanudar">
                    <span class="btn-icon" id="pauseIcon">‚è∏Ô∏è</span>
                    <span class="btn-text" id="pauseText">Pausar</span>
                </button>
                <button class="control-btn replay" id="replayBtn" disabled title="Repetir Animaci√≥n">
                    <span class="btn-icon">üîÑ</span>
                    <span class="btn-text">Repetir</span>
                </button>
            </div>

            <!-- Input de texto inferior -->
            <div class="input-container">
                <input 
                    type="text" 
                    class="text-input" 
                    id="textInput" 
                    placeholder="Escribe una frase aqu√≠... ej: hola buenos dias"
                    autocomplete="off"
                >
                <button class="animate-btn" id="animateBtn">
                    ANIMAR
                </button>
            </div>
        </div>
    </div>

    <div id="loading">
        <div class="spinner"></div>
        <div class="loading-text" id="loading-text">Inicializando...</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- Traductor LSV Standalone para GitHub Pages -->
    <script src="./lsv-translator.js?v=2.4.0"></script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Funci√≥n para enviar logs a React Native
        function logToExpo(message, data = null) {
            const logMessage = data ? `${message} ${JSON.stringify(data)}` : message;
            console.log(logMessage); // Tambi√©n en consola web
            
            // Enviar a React Native si est√° disponible
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    type: 'LOG',
                    message: message,
                    data: data,
                    timestamp: new Date().toISOString()
                }));
            }
        }

        let scene, camera, renderer, controls, clock;
        let avatarModel, mixer;
        let animationCache = new Map();
        let currentAction = null;
        let avatarActual = 'Duvall';
        let isPaused = false;
        let ultimoTexto = '';
        let isAnimating = false;
        
        // Control de API backend
        let useBackendAPI = false;  // DESACTIVADO temporalmente - Red m√≥vil muy lenta
        const BACKEND_URL = 'http://10.171.95.217:5000';
        
        // Control de teclado virtual y viewport
        let initialViewportHeight = window.innerHeight;
        let isKeyboardOpen = false;
        let savedCameraState = null;
        
        // Optimizaciones de rendimiento
        let loaderInstance = null; // Reutilizar loader
        let preloadQueue = [];
        let isPreloading = false;
        
        // Detecci√≥n de dispositivo m√≥vil
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // ================================================
        // SISTEMA DE CACH√â PERSISTENTE CON INDEXEDDB
        // ================================================
        let db = null;
        const DB_NAME = 'LSVAnimacionesDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'animaciones';
        
        // Inicializar IndexedDB al cargar
        async function initIndexedDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => {
                    console.warn('‚ö†Ô∏è IndexedDB no disponible, usando solo RAM');
                    logToExpo('‚ö†Ô∏è IndexedDB no disponible');
                    resolve(null);
                };
                
                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log('‚úÖ IndexedDB inicializado');
                    logToExpo('‚úÖ Cach√© persistente activa');
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const store = db.createObjectStore(STORE_NAME, { keyPath: 'key' });
                        store.createIndex('avatar', 'avatar', { unique: false });
                        store.createIndex('timestamp', 'timestamp', { unique: false });
                        console.log('‚úÖ Base de datos creada');
                    }
                };
            });
        }
        
        // Guardar animaci√≥n en IndexedDB
        async function saveAnimationToDB(key, clipData, avatar) {
            if (!db) return;
            
            try {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                
                const data = {
                    key: key,
                    avatar: avatar,
                    clipData: clipData,
                    timestamp: Date.now()
                };
                
                await store.put(data);
                console.log(`üíæ Guardado en DB: ${key}`);
            } catch (error) {
                console.warn('‚ö†Ô∏è Error guardando en DB:', error);
            }
        }
        
        // Eliminar entrada espec√≠fica de IndexedDB (para forzar recarga)
        async function deleteAnimationFromDB(key) {
            if (!db) return;
            
            return new Promise((resolve) => {
                try {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.delete(key);
                    
                    request.onsuccess = () => {
                        console.log(`üóëÔ∏è Cache eliminado: ${key}`);
                        resolve(true);
                    };
                    
                    request.onerror = () => resolve(false);
                } catch (error) {
                    console.warn('‚ö†Ô∏è Error eliminando cache:', error);
                    resolve(false);
                }
            });
        }
        
        // Cargar animaci√≥n desde IndexedDB
        async function loadAnimationFromDB(key) {
            if (!db) return null;
            
            return new Promise((resolve) => {
                try {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.get(key);
                    
                    request.onsuccess = () => {
                        if (request.result) {
                            console.log(`üìÇ Cargado desde DB: ${key}`);
                            resolve(request.result.clipData);
                        } else {
                            resolve(null);
                        }
                    };
                    
                    request.onerror = () => resolve(null);
                } catch (error) {
                    console.warn('‚ö†Ô∏è Error cargando desde DB:', error);
                    resolve(null);
                }
            });
        }
        
        // Serializar AnimationClip para IndexedDB
        function serializeAnimationClip(clip) {
            return {
                name: clip.name,
                duration: clip.duration,
                tracks: clip.tracks.map(track => ({
                    name: track.name,
                    times: Array.from(track.times),
                    values: Array.from(track.values),
                    type: track.constructor.name
                }))
            };
        }
        
        // Deserializar AnimationClip desde IndexedDB
        function deserializeAnimationClip(data) {
            const tracks = data.tracks.map(trackData => {
                let TrackConstructor;
                switch (trackData.type) {
                    case 'VectorKeyframeTrack':
                        TrackConstructor = THREE.VectorKeyframeTrack;
                        break;
                    case 'QuaternionKeyframeTrack':
                        TrackConstructor = THREE.QuaternionKeyframeTrack;
                        break;
                    case 'NumberKeyframeTrack':
                        TrackConstructor = THREE.NumberKeyframeTrack;
                        break;
                    default:
                        TrackConstructor = THREE.KeyframeTrack;
                }
                return new TrackConstructor(
                    trackData.name,
                    new Float32Array(trackData.times),
                    new Float32Array(trackData.values)
                );
            });
            
            return new THREE.AnimationClip(data.name, data.duration, tracks);
        }
        
        // ================================================
        // UTILIDADES
        // ================================================
        
        // Actualizar indicador visual de estado
        function updateStatus(mensaje, loading = false) {
            // Funci√≥n placeholder para evitar errores
            // Puede implementarse con un elemento de status si se necesita UI
            console.log(`üìä Estado: ${mensaje}`);
        }
        
        
        /**
         * Normaliza texto espa√±ol: quita tildes pero MANTIENE √±
         * Equivalente a la funci√≥n normalizar_texto_espanol del backend Python
         * 
         * @param {string} texto - Texto a normalizar
         * @returns {string} - Texto normalizado (sin tildes, con √±)
         * 
         * Ejemplos:
         * - "d√≠a" ‚Üí "dia"
         * - "ni√±o" ‚Üí "ni√±o"  (mantiene √±)
         * - "Jos√©" ‚Üí "jose"
         * - "se√±or" ‚Üí "se√±or" (mantiene √±)
         */
        function normalizarTextoEspanol(texto) {
            // Placeholder temporal para preservar √± y √ë
            const textoConPlaceholder = texto
                .replace(/√±/g, '\x01')
                .replace(/√ë/g, '\x02');
            
            // Normalizar NFD y eliminar diacr√≠ticos
            const textoNormalizado = textoConPlaceholder
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '');
            
            // Restaurar √± y √ë
            return textoNormalizado
                .replace(/\x01/g, '√±')
                .replace(/\x02/g, '√ë');
        }
        const MAX_CACHE_SIZE = isMobile ? 25 : 50; // Aumentado para m√≥vil
        const PRELOAD_COUNT = isMobile ? 5 : 10; // Aumentado para m√≥vil
        const LOAD_DELAY = isMobile ? 200 : 100; // Reducido para m√≥vil
        const LOOKAHEAD = isMobile ? 4 : 5; // Aumentado: precargar m√°s por adelantado
        const GLB_LOAD_TIMEOUT = isMobile ? 15000 : 20000; // Timeout para carga de GLB (15s m√≥vil, 20s desktop)
        
        // Sistema de precarga anticipada
        let currentSequence = [];
        let currentIndex = 0;
        
        // Posici√≥n inicial de la c√°mara
        const INITIAL_CAMERA_POSITION = { x: 0, y: 1.6, z: 2.2 };
        const INITIAL_CAMERA_TARGET = { x: 0, y: 1.2, z: 0 };
        
        // Palabras que se omiten en LSV (no se traducen)
        const PALABRAS_OMITIDAS = new Set([
            // Art√≠culos definidos
            'el', 'la', 'los', 'las',
            // Art√≠culos indefinidos (solo plural, 'un' se traduce como 1)
            'una', 'unos', 'unas',
            // Preposiciones que no existen en LSV
            'de', 'del', 'al', 'a', 'ante', 'bajo', 'con', 'contra', 'desde', 'durante', 'en', 'entre', 'hacia', 'hasta', 'para', 'por', 'segun', 'sin', 'sobre', 'tras',
            // Conectores que se omiten
            'y', 'e', 'o', 'u', 'ni',
            // Pronombres que se omiten en ciertos contextos
            'se', 'me', 'te', 'le', 'les', 'nos',
            // Demostrativos que se omiten
            'esta', 'este', 'ese', 'esa', 'aquel', 'aquella', 'estos', 'estas', 'esos', 'esas', 'aquellos', 'aquellas',
            // Signos de interrogaci√≥n (se procesar√°n aparte)
        ]);
        
        // Palabras de TIEMPO que van al inicio en LSV
        const PALABRAS_TIEMPO = new Set([
            'ayer', 'hoy', 'ma√±ana', 'anteayer', 'pasado ma√±ana',
            'hace rato', 'hace a√±os', 'hab√≠a una vez', 'antes',
            'ahora', 'despues', 'luego', 'pronto', 'tarde', 'temprano',
            'lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo',
            'enero', 'febrero', 'marzo', 'abril', 'mayo', 'junio',
            'julio', 'agosto', 'septiembre', 'octubre', 'noviembre', 'diciembre',
        ]);
        
        // Palabras FEMENINAS que requieren MUJER despu√©s
        const PALABRAS_FEMENINAS = {
            'maestra': 'maestro',
            'profesora': 'profesor',
            'doctora': 'medico',
            'enfermera': 'enfermera', // Ya existe como femenino
            'abuela': 'abuelo',
            'nieta': 'nieto',
            'tia': 'tio',
            'prima': 'primo',
            'sobrina': 'sobrino',
            'suegra': 'suegro',
            'cu√±ada': 'cu√±ado',
            'hermana': 'hermano',
            'hija': 'hijo',
            'mama': 'papa',
            'madre': 'padre',
            'madrina': 'padrino',
            'madrastra': 'padrastro',
            'hijastra': 'hijastro',
            'hermanastra': 'hermanastro',
            'se√±ora': 'se√±or',
            'novia': 'novio',
            'amiga': 'amigo',
            'vieja': 'viejo',
            'ni√±a': 'ni√±o',
            'jefa': 'jefe',
            'directora': 'director',
            'gerenta': 'gerente',
            'secretaria': 'secretaria', // Ya existe
            'vendedora': 'vendedor',
            'cocinera': 'cocinero',
            'peluquera': 'peluquera', // Ya existe
            'dibujante': 'dibujante', // Neutro
            'abogada': 'abogado',
            'administradora': 'administrador',
            'contadora': 'contador',
            'economista': 'economista', // Neutro
            'ingeniera': 'ingeniero',
            'psicologa': 'psicologo',
            'detective': 'detective', // Neutro
        };
        
        // Normalizaciones de plural a singular y otras simplificaciones LSV
        const NORMALIZACION_LSV = {
            // Plurales ‚Üí Singular
            'todos': 'todo',
            'todas': 'todo',
            'muchos': 'mucho',
            'muchas': 'mucho',
            'pocos': 'poco',
            'pocas': 'poco',
            'algunos': 'algun',
            'algunas': 'algun',
            'ningunos': 'ningun',
            'ningunas': 'ningun',
            'otros': 'otro',
            'otras': 'otro',
            'demasiados': 'demasiado',
            'demasiadas': 'demasiado',
            'bastantes': 'bastante',
            
            // D√≠as de la semana (formas alternativas)
            'lun': 'lunes',
            'mar': 'martes',
            'mie': 'miercoles',
            'jue': 'jueves',
            'vie': 'viernes',
            'sab': 'sabado',
            'dom': 'domingo',
            
            // Meses
            'ene': 'enero',
            'feb': 'febrero',
            'mar': 'marzo',
            'abr': 'abril',
            'may': 'mayo',
            'jun': 'junio',
            'jul': 'julio',
            'ago': 'agosto',
            'sep': 'septiembre',
            'oct': 'octubre',
            'nov': 'noviembre',
            'dic': 'diciembre',
            
            // Simplificaciones comunes
            'dias': 'dia',
            'a√±os': 'a√±o',
            'meses': 'mes',
            'semanas': 'semana',
            'horas': 'hora',
            'minutos': 'minuto',
            'segundos': 'segundo',
            
            // Pronombres en plural
            'nosotras': 'nosotros',
            'vosotros': 'ustedes',
            'vosotras': 'ustedes',
            
            // Pronombres posesivos ‚Üí LSV
            'mi': 'mio',
            'mis': 'mio',
            'tu': 'tuyo',
            'tus': 'tuyo',
            'su': 'suyo',
            'sus': 'suyo',
            'nuestro': 'nuestro',
            'nuestra': 'nuestro',
            'nuestros': 'nuestro',
            'nuestras': 'nuestro',
        };
        
        // Sistema de normalizaci√≥n de verbos (conjugaciones ‚Üí infinitivo)
        const NORMALIZACION_VERBOS = {
            // Trabajar
            'trabajo': 'trabajar', 'trabajas': 'trabajar', 'trabaja': 'trabajar',
            'trabajamos': 'trabajar', 'trabajan': 'trabajar', 'trabaj√©': 'trabajar',
            'trabajaste': 'trabajar', 'trabaj√≥': 'trabajar', 'trabajaron': 'trabajar',
            'trabajaba': 'trabajar', 'trabajando': 'trabajar',
            
            // Estudiar
            'estudio': 'estudiar', 'estudias': 'estudiar', 'estudia': 'estudiar',
            'estudiamos': 'estudiar', 'estudian': 'estudiar', 'estudi√©': 'estudiar',
            'estudiaste': 'estudiar', 'estudi√≥': 'estudiar', 'estudiaron': 'estudiar',
            'estudiaba': 'estudiar', 'estudiando': 'estudiar',
            
            // Comer
            'como': 'comer', 'comes': 'comer', 'come': 'comer',
            'comemos': 'comer', 'comen': 'comer', 'com√≠': 'comer',
            'comiste': 'comer', 'comi√≥': 'comer', 'comieron': 'comer',
            'com√≠a': 'comer', 'comiendo': 'comer',
            
            // Vivir
            'vivo': 'vivir', 'vives': 'vivir', 'vive': 'vivir',
            'vivimos': 'vivir', 'viven': 'vivir', 'viv√≠': 'vivir',
            'viviste': 'vivir', 'vivi√≥': 'vivir', 'vivieron': 'vivir',
            'viv√≠a': 'vivir', 'viviendo': 'vivir',
            
            // Dormir
            'duermo': 'dormir', 'duermes': 'dormir', 'duerme': 'dormir',
            'dormimos': 'dormir', 'duermen': 'dormir', 'dorm√≠': 'dormir',
            'dormiste': 'dormir', 'durmi√≥': 'dormir', 'durmieron': 'dormir',
            'dorm√≠a': 'dormir', 'durmiendo': 'dormir',
            
            // Ver
            'veo': 'ver', 'ves': 'ver', 've': 'ver',
            'vemos': 'ver', 'ven': 'ver', 'vi': 'ver',
            'viste': 'ver', 'vio': 'ver', 'vieron': 'ver',
            've√≠a': 'ver', 'viendo': 'ver',
            
            // Estar
            'estoy': 'estar', 'est√°s': 'estar', 'est√°': 'estar',
            'estamos': 'estar', 'est√°n': 'estar', 'estuve': 'estar',
            'estuviste': 'estar', 'estuvo': 'estar', 'estuvieron': 'estar',
            'estaba': 'estar', 'estando': 'estar',
            
            // Ser
            'soy': 'ser', 'eres': 'ser', 'es': 'ser',
            'somos': 'ser', 'son': 'ser', 'fui': 'ser',
            'fuiste': 'ser', 'fue': 'ser', 'fueron': 'ser',
            'era': 'ser', 'siendo': 'ser',
            
            // Ayudar
            'ayudo': 'ayudar', 'ayudas': 'ayudar', 'ayuda': 'ayudar',
            'ayudamos': 'ayudar', 'ayudan': 'ayudar', 'ayud√©': 'ayudar',
            'ayudando': 'ayudar',
            
            // Amar
            'amo': 'amar', 'amas': 'amar', 'ama': 'amar',
            'amamos': 'amar', 'aman': 'amar', 'am√©': 'amar',
            'amando': 'amar',
            
            // Cansar
            'canso': 'cansar', 'cansas': 'cansar', 'cansa': 'cansar',
            'cansamos': 'cansar', 'cansan': 'cansar', 'cans√©': 'cansar',
            'cansando': 'cansar',
            
            // Conocer
            'conozco': 'conocer', 'conoces': 'conocer', 'conoce': 'conocer',
            'conocemos': 'conocer', 'conocen': 'conocer', 'conoc√≠': 'conocer',
            'conociendo': 'conocer',
            
            // Decir
            'digo': 'decir', 'dices': 'decir', 'dice': 'decir',
            'decimos': 'decir', 'dicen': 'decir', 'dije': 'decir',
            'diciendo': 'decir',
            
            // Deletrear
            'deletreo': 'deletrear', 'deletreas': 'deletrear', 'deletrea': 'deletrear',
            'deletreamos': 'deletrear', 'deletrean': 'deletrear',
            
            // Invitar
            'invito': 'invitar', 'invitas': 'invitar', 'invita': 'invitar',
            'invitamos': 'invitar', 'invitan': 'invitar', 'invit√©': 'invitar',
            'invitando': 'invitar',
            
            // Preguntar
            'pregunto': 'preguntar', 'preguntas': 'preguntar', 'pregunta': 'preguntar',
            'preguntamos': 'preguntar', 'preguntan': 'preguntar', 'pregunt√©': 'preguntar',
            'preguntando': 'preguntar',
            
            // Presentar
            'presento': 'presentar', 'presentas': 'presentar', 'presenta': 'presentar',
            'presentamos': 'presentar', 'presentan': 'presentar', 'present√©': 'presentar',
            'presentando': 'presentar',
            
            // Querer
            'quiero': 'querer', 'quieres': 'querer', 'quiere': 'querer',
            'queremos': 'querer', 'quieren': 'querer', 'quise': 'querer',
            'queriendo': 'querer',
            
            // Responder
            'respondo': 'responder', 'respondes': 'responder', 'responde': 'responder',
            'respondemos': 'responder', 'responden': 'responder', 'respond√≠': 'responder',
            'respondiendo': 'responder',
            
            // Saludar
            'saludo': 'saludar', 'saludas': 'saludar', 'saluda': 'saludar',
            'saludamos': 'saludar', 'saludan': 'saludar', 'salud√©': 'saludar',
            'saludando': 'saludar',
            
            // Sentir
            'siento': 'sentir', 'sientes': 'sentir', 'siente': 'sentir',
            'sentimos': 'sentir', 'sienten': 'sentir', 'sent√≠': 'sentir',
            'sintiendo': 'sentir',
            
            // Correr
            'corro': 'correr', 'corres': 'correr', 'corre': 'correr',
            'corremos': 'correr', 'corren': 'correr', 'corr√≠': 'correr',
            'corriendo': 'correr',
            
            // Entrar
            'entro': 'entrar', 'entras': 'entrar', 'entra': 'entrar',
            'entramos': 'entrar', 'entran': 'entrar', 'entr√©': 'entrar',
            'entrando': 'entrar',
            
            // Viajar
            'viajo': 'viajar', 'viajas': 'viajar', 'viaja': 'viajar',
            'viajamos': 'viajar', 'viajan': 'viajar', 'viaj√©': 'viajar',
            'viajando': 'viajar',
        };
        
        // Funci√≥n para convertir n√∫mero a secuencia de glosas LSV
        function numeroAGlosas(numero) {
            const num = parseInt(numero);
            
            // N√∫meros 0-10: directos
            if (num >= 0 && num <= 10) {
                return [num.toString()];
            }
            
            // N√∫meros 11-19: 10 + segundo d√≠gito
            if (num >= 11 && num <= 19) {
                const segundoDigito = num % 10;
                return ['10', segundoDigito.toString()];
            }
            
            // N√∫meros 20+: separar cada d√≠gito
            if (num >= 20) {
                return numero.split('');
            }
            
            return null;
        }
        
        // Funci√≥n para normalizar palabras (convertir conjugaciones a infinitivos)
        function normalizarPalabra(palabra) {
            // PRIMERO: Normalizar tildes y convertir a min√∫sculas (preservando √±)
            // Esto convierte "d√≠as" ‚Üí "dias", "Jos√©" ‚Üí "jose", "ni√±o" ‚Üí "ni√±o"
            const palabraLower = normalizarTextoEspanol(palabra.toLowerCase());
            
            // 0. Verificar si es un n√∫mero
            if (/^\d+$/.test(palabraLower)) {
                return palabraLower; // Retornar el n√∫mero como est√°, se procesar√° despu√©s
            }
            
            // 1. Verificar si es una palabra que se omite en LSV (art√≠culos, preposiciones, etc.)
            if (PALABRAS_OMITIDAS.has(palabraLower)) {
                return null; // null indica que se debe omitir
            }
            
            // 2. Verificar normalizaciones LSV (plural ‚Üí singular, etc.)
            if (NORMALIZACION_LSV[palabraLower]) {
                return NORMALIZACION_LSV[palabraLower];
            }
            
            // 3. Verificar normalizaciones de verbos
            if (NORMALIZACION_VERBOS[palabraLower]) {
                return NORMALIZACION_VERBOS[palabraLower];
            }
            
            // 4. Si est√° directamente en el diccionario, retornar como est√°
            if (DICCIONARIO[palabraLower]) {
                return palabraLower;
            }
            
            // 5. Reglas gen√©ricas para verbos regulares no mapeados
            // Presente: -o, -as, -a, -amos, -√°is, -an ‚Üí -ar/-er/-ir
            if (palabraLower.endsWith('ando') || palabraLower.endsWith('iendo')) {
                // Gerundio
                const raiz = palabraLower.slice(0, -4);
                const candidatos = [raiz + 'ar', raiz + 'er', raiz + 'ir'];
                for (const candidato of candidatos) {
                    if (DICCIONARIO[candidato]) return candidato;
                }
            }
            
            if (palabraLower.endsWith('o') && palabraLower.length > 2) {
                const raiz = palabraLower.slice(0, -1);
                const candidatos = [raiz + 'ar', raiz + 'er', raiz + 'ir'];
                for (const candidato of candidatos) {
                    if (DICCIONARIO[candidato]) return candidato;
                }
            }
            
            if (palabraLower.endsWith('as') || palabraLower.endsWith('es')) {
                const raiz = palabraLower.slice(0, -2);
                const candidatos = [raiz + 'ar', raiz + 'er', raiz + 'ir'];
                for (const candidato of candidatos) {
                    if (DICCIONARIO[candidato]) return candidato;
                }
            }
            
            if (palabraLower.endsWith('a') && palabraLower.length > 2) {
                const raiz = palabraLower.slice(0, -1);
                if (DICCIONARIO[raiz + 'ar']) return raiz + 'ar';
            }
            
            if (palabraLower.endsWith('e') && palabraLower.length > 2) {
                const raiz = palabraLower.slice(0, -1);
                const candidatos = [raiz + 'er', raiz + 'ar', raiz + 'ir'];
                for (const candidato of candidatos) {
                    if (DICCIONARIO[candidato]) return candidato;
                }
            }
            
            if (palabraLower.endsWith('amos') || palabraLower.endsWith('emos') || palabraLower.endsWith('imos')) {
                const raiz = palabraLower.slice(0, -4);
                const candidatos = [raiz + 'ar', raiz + 'er', raiz + 'ir'];
                for (const candidato of candidatos) {
                    if (DICCIONARIO[candidato]) return candidato;
                }
            }
            
            if (palabraLower.endsWith('an') || palabraLower.endsWith('en')) {
                const raiz = palabraLower.slice(0, -2);
                const candidatos = [raiz + 'ar', raiz + 'er', raiz + 'ir'];
                for (const candidato of candidatos) {
                    if (DICCIONARIO[candidato]) return candidato;
                }
            }
            
            // Si no se encontr√≥ ninguna normalizaci√≥n, retornar la palabra original
            return palabraLower;
        }
        
        // Diccionario de mapeo
                                const DICCIONARIO = {
            // üìå Generado autom√°ticamente desde backend/scripts/data.json (413 palabras totales, 33 en carpeta nuevo)
            '0': { categoria: 'numero', archivo: '0' },
            '1': { categoria: 'numero', archivo: '1' },
            '10': { categoria: 'numero', archivo: '10' },
            '10_o': { categoria: 'ordinales', archivo: '10_o' },
            '1_o': { categoria: 'ordinales', archivo: '1_o' },
            '1m': { categoria: 'numero', archivo: '1m' },
            '2': { categoria: 'numero', archivo: '2' },
            '2_o': { categoria: 'ordinales', archivo: '2_o' },
            '3': { categoria: 'numero', archivo: '3' },
            '3_o': { categoria: 'ordinales', archivo: '3_o' },
            '4': { categoria: 'numero', archivo: '4' },
            '4_o': { categoria: 'ordinales', archivo: '4_o' },
            '5': { categoria: 'numero', archivo: '5' },
            '5_o': { categoria: 'ordinales', archivo: '5_o' },
            '6': { categoria: 'numero', archivo: '6' },
            '6_o': { categoria: 'ordinales', archivo: '6_o' },
            '7': { categoria: 'numero', archivo: '7' },
            '7_o': { categoria: 'ordinales', archivo: '7_o' },
            '8': { categoria: 'numero', archivo: '8' },
            '8_o': { categoria: 'ordinales', archivo: '8_o' },
            '9': { categoria: 'numero', archivo: '9' },
            '9_o': { categoria: 'ordinales', archivo: '9_o' },
            'a': { categoria: 'alfabeto', archivo: 'a' },
            'a la orden': { categoria: 'cortesia', archivo: 'a la orden' },
            'aboga': { categoria: 'profesiones', archivo: 'abogado' },
            'abogado': { categoria: 'profesiones', archivo: 'abogado' },
            'abogados': { categoria: 'profesiones', archivo: 'abogado' },
            'abril': { categoria: 'expresiones', archivo: 'abril' },
            'adios': { categoria: 'saludos', archivo: 'adios' },
            'administrador': { categoria: 'profesiones', archivo: 'administrador' },
            'administradors': { categoria: 'profesiones', archivo: 'administrador' },
            'adulto': { categoria: 'personas', archivo: 'adulto' },
            'adverbios': { categoria: 'adverbios', archivo: 'adverbios' },
            'agarrar': { categoria: 'verbos', archivo: 'agarrar' },
            'agosto': { categoria: 'expresiones', archivo: 'agosto' },
            'al lado': { categoria: 'adverbios', archivo: 'al lado' },
            'alba√±il': { categoria: 'profesiones', archivo: 'alba√±il' },
            'alba√±ils': { categoria: 'profesiones', archivo: 'alba√±il' },
            'algo': { categoria: 'preposiciones', archivo: 'algo' },
            'alguien': { categoria: 'preposiciones', archivo: 'alguien' },
            'algun': { categoria: 'preposiciones', archivo: 'algun' },
            'amar': { categoria: 'verbos', archivo: 'amar' },
            'amigo': { categoria: 'personas', archivo: 'amigo' },
            'analista': { categoria: 'profesiones', archivo: 'analista' },
            'analistas': { categoria: 'profesiones', archivo: 'analista' },
            'anciano': { categoria: 'personas', archivo: 'anciano' },
            'anteayer': { categoria: 'tiempo', archivo: 'anteayer' },
            'apartamento': { categoria: 'viviendas', archivo: 'apartamento' },
            'atraer': { categoria: 'verbos', archivo: 'atraer' },
            'atras': { categoria: 'adverbios', archivo: 'atras' },
            'auxiliar': { categoria: 'profesiones', archivo: 'auxiliar' },
            'auxiliars': { categoria: 'profesiones', archivo: 'auxiliar' },
            'ayer': { categoria: 'tiempo', archivo: 'ayer' },
            'ayudar': { categoria: 'verbos', archivo: 'ayudar' },
            'b': { categoria: 'alfabeto', archivo: 'b' },
            'barbero': { categoria: 'profesiones', archivo: 'barbero' },
            'barberos': { categoria: 'profesiones', archivo: 'barbero' },
            'bastante': { categoria: 'preposiciones', archivo: 'bastante' },
            'ba√±o': { categoria: 'viviendas', archivo: 'ba√±o' },
            'bebe': { categoria: 'personas', archivo: 'bebe' },
            'bien': { categoria: 'expresiones', archivo: 'bien' },
            'bienvenido': { categoria: 'saludos', archivo: 'bienvenido' },
            'buen provecho': { categoria: 'cortesia', archivo: 'buen provecho' },
            'buenas noches': { categoria: 'saludos', archivo: 'buenas noches' },
            'buenas tardes': { categoria: 'saludos', archivo: 'buenas tardes' },
            'buenasnoches': { categoria: 'saludos', archivo: 'buenas noches' },
            'buenastardes': { categoria: 'saludos', archivo: 'buenas tardes' },
            'buenos dias': { categoria: 'saludos', archivo: 'buenos dias' },
            'buenosdias': { categoria: 'saludos', archivo: 'buenos dias' },
            'burlar': { categoria: 'verbos', archivo: 'burlar' },
            'c': { categoria: 'alfabeto', archivo: 'c' },
            'calendario': { categoria: 'tiempo', archivo: 'calendario' },
            'calmar': { categoria: 'verbos', archivo: 'calmar' },
            'cansar': { categoria: 'verbos', archivo: 'cansar' },
            'carrera': { categoria: 'profesiones', archivo: 'carrera' },
            'carreras': { categoria: 'profesiones', archivo: 'carrera' },
            'casa': { categoria: 'viviendas', archivo: 'casa' },
            'casado': { categoria: 'estado_civil', archivo: 'casado' },
            'cerca': { categoria: 'adverbios', archivo: 'cerca' },
            'chao': { categoria: 'saludos', archivo: 'chao' },
            'chef': { categoria: 'profesiones', archivo: 'chef' },
            'chefs': { categoria: 'profesiones', archivo: 'chef' },
            'ciego': { categoria: 'personas', archivo: 'ciego' },
            'cocina': { categoria: 'viviendas', archivo: 'cocina' },
            'cocinero': { categoria: 'profesiones', archivo: 'cocinero' },
            'cocineros': { categoria: 'profesiones', archivo: 'cocinero' },
            'comedor': { categoria: 'viviendas', archivo: 'comedor' },
            'comer': { categoria: 'verbos', archivo: 'comer' },
            'como': { categoria: 'expresiones', archivo: 'como' },
            'como estas': { categoria: 'interrogantes', archivo: 'como estas' },
            'compa√±ero': { categoria: 'personas', archivo: 'compa√±ero' },
            'concubino': { categoria: 'estado_civil', archivo: 'concubino' },
            'conductor': { categoria: 'profesiones', archivo: 'conductor' },
            'conductors': { categoria: 'profesiones', archivo: 'conductor' },
            'conocer': { categoria: 'verbos', archivo: 'conocer' },
            'constructor': { categoria: 'profesiones', archivo: 'constructor' },
            'constructors': { categoria: 'profesiones', archivo: 'constructor' },
            'contador': { categoria: 'profesiones', archivo: 'contador' },
            'contadors': { categoria: 'profesiones', archivo: 'contador' },
            'cortesia': { categoria: 'cortesia', archivo: 'cortesia' },
            'cual': { categoria: 'expresiones', archivo: 'cual' },
            'cual es tu nombre': { categoria: 'interrogantes', archivo: 'cual es tu nombre' },
            'cual es tu sena': { categoria: 'interrogantes', archivo: 'cual es tu sena' },
            'cualquier': { categoria: 'preposiciones', archivo: 'cualquier' },
            'cuando': { categoria: 'expresiones', archivo: 'cuando' },
            'cuantos': { categoria: 'expresiones', archivo: 'cuantos' },
            'cuarto': { categoria: 'viviendas', archivo: 'cuarto' },
            'd': { categoria: 'alfabeto', archivo: 'd' },
            'de nada': { categoria: 'expresiones', archivo: 'de nada' },
            'decir': { categoria: 'verbos', archivo: 'decir' },
            'deletrear': { categoria: 'verbos', archivo: 'deletrear' },
            'demasiado': { categoria: 'preposiciones', archivo: 'demasiado' },
            'dentista': { categoria: 'profesiones', archivo: 'dentista' },
            'dentistas': { categoria: 'profesiones', archivo: 'dentista' },
            'derecha': { categoria: 'adverbios', archivo: 'derecha' },
            'detective': { categoria: 'profesiones', archivo: 'detective' },
            'detectives': { categoria: 'profesiones', archivo: 'detective' },
            'dia': { categoria: 'tiempo', archivo: 'dia' },
            'dibujante': { categoria: 'profesiones', archivo: 'dibujante' },
            'dibujante tecnico': { categoria: 'profesiones', archivo: 'dibujante tecnico' },
            'dibujante tecnicos': { categoria: 'profesiones', archivo: 'dibujante tecnico' },
            'dibujantes': { categoria: 'profesiones', archivo: 'dibujante' },
            'diciembre': { categoria: 'expresiones', archivo: 'diciembre' },
            'director': { categoria: 'profesiones', archivo: 'director' },
            'directors': { categoria: 'profesiones', archivo: 'director' },
            'divorciado': { categoria: 'estado_civil', archivo: 'divorciado' },
            'doc': { categoria: 'profesiones', archivo: 'medico' },
            'domingo': { categoria: 'dias_semana', archivo: 'domingo' },
            'donde': { categoria: 'expresiones', archivo: 'donde' },
            'donde (especifico)': { categoria: 'expresiones', archivo: 'donde (especifico)' },
            'dormir': { categoria: 'verbos', archivo: 'dormir' },
            'e': { categoria: 'alfabeto', archivo: 'e' },
            'economista': { categoria: 'profesiones', archivo: 'economista' },
            'economistas': { categoria: 'profesiones', archivo: 'economista' },
            'edificio': { categoria: 'viviendas', archivo: 'edificio' },
            'el': { categoria: 'pronombres', archivo: 'el' },
            'ella': { categoria: 'pronombres', archivo: 'ella' },
            'ellas': { categoria: 'pronombres', archivo: 'ellas' },
            'ellos': { categoria: 'pronombres', archivo: 'ellos' },
            'en punto': { categoria: 'general', archivo: 'en punto' },
            'enero': { categoria: 'expresiones', archivo: 'enero' },
            'enfermera': { categoria: 'profesiones', archivo: 'enfermera' },
            'enfermeras': { categoria: 'profesiones', archivo: 'enfermera' },
            'enganar': { categoria: 'verbos', archivo: 'enganar' },
            'escritor': { categoria: 'profesiones', archivo: 'escritor' },
            'escritors': { categoria: 'profesiones', archivo: 'escritor' },
            'estar': { categoria: 'verbos', archivo: 'estar' },
            'estudiar': { categoria: 'verbos', archivo: 'estudiar' },
            'expresiones': { categoria: 'expresiones', archivo: 'expresiones' },
            'f': { categoria: 'alfabeto', archivo: 'f' },
            'febrero': { categoria: 'expresiones', archivo: 'febrero' },
            'fin de semana': { categoria: 'tiempo', archivo: 'fin de semana' },
            'fotografo': { categoria: 'profesiones', archivo: 'fotografo' },
            'fotografos': { categoria: 'profesiones', archivo: 'fotografo' },
            'frente': { categoria: 'adverbios', archivo: 'frente' },
            'g': { categoria: 'alfabeto', archivo: 'g' },
            'gerente': { categoria: 'profesiones', archivo: 'gerente' },
            'gerentes': { categoria: 'profesiones', archivo: 'gerente' },
            'gracias': { categoria: 'cortesia', archivo: 'gracias' },
            'guardar': { categoria: 'verbos', archivo: 'guardar' },
            'h': { categoria: 'alfabeto', archivo: 'h' },
            'hola': { categoria: 'saludos', archivo: 'hola' },
            'holi': { categoria: 'saludos', archivo: 'hola' },
            'holiwis': { categoria: 'saludos', archivo: 'hola' },
            'hombre': { categoria: 'personas', archivo: 'hombre' },
            'hora': { categoria: 'general', archivo: 'hora' },
            'horario': { categoria: 'general', archivo: 'horario' },
            'horita': { categoria: 'tiempo', archivo: 'hoy' },
            'hoy': { categoria: 'tiempo', archivo: 'hoy' },
            'i': { categoria: 'alfabeto', archivo: 'i' },
            'informatica': { categoria: 'profesiones', archivo: 'informatica' },
            'informaticas': { categoria: 'profesiones', archivo: 'informatica' },
            'inge': { categoria: 'profesiones', archivo: 'ingeniero' },
            'ingeniero': { categoria: 'profesiones', archivo: 'ingeniero' },
            'ingenieros': { categoria: 'profesiones', archivo: 'ingeniero' },
            'inspector': { categoria: 'profesiones', archivo: 'inspector' },
            'inspectors': { categoria: 'profesiones', archivo: 'inspector' },
            'instructor': { categoria: 'profesiones', archivo: 'instructor' },
            'instructors': { categoria: 'profesiones', archivo: 'instructor' },
            'interprete': { categoria: 'profesiones', archivo: 'interprete' },
            'interpretes': { categoria: 'profesiones', archivo: 'interprete' },
            'interrogantes': { categoria: 'expresiones', archivo: 'interrogantes' },
            'invitar': { categoria: 'verbos', archivo: 'invitar' },
            'izquierda': { categoria: 'adverbios', archivo: 'izquierda' },
            'j': { categoria: 'alfabeto', archivo: 'j' },
            'jefe': { categoria: 'profesiones', archivo: 'jefe' },
            'jefes': { categoria: 'profesiones', archivo: 'jefe' },
            'joven': { categoria: 'personas', archivo: 'joven' },
            'jueves': { categoria: 'dias_semana', archivo: 'jueves' },
            'julio': { categoria: 'expresiones', archivo: 'julio' },
            'junio': { categoria: 'expresiones', archivo: 'junio' },
            'k': { categoria: 'alfabeto', archivo: 'k' },
            'l': { categoria: 'alfabeto', archivo: 'l' },
            'lejos': { categoria: 'adverbios', archivo: 'lejos' },
            'licenciado': { categoria: 'profesiones', archivo: 'licenciado' },
            'licenciados': { categoria: 'profesiones', archivo: 'licenciado' },
            'llevar': { categoria: 'verbos', archivo: 'llevar' },
            'lugares': { categoria: 'adverbios', archivo: 'lugares' },
            'lunes': { categoria: 'dias_semana', archivo: 'lunes' },
            'm': { categoria: 'alfabeto', archivo: 'm' },
            'maestro': { categoria: 'profesiones', archivo: 'maestro' },
            'maestros': { categoria: 'profesiones', archivo: 'maestro' },
            'mal': { categoria: 'expresiones', archivo: 'mal' },
            'martes': { categoria: 'dias_semana', archivo: 'martes' },
            'marzo': { categoria: 'expresiones', archivo: 'marzo' },
            'mas': { categoria: 'preposiciones', archivo: 'mas' },
            'mayo': { categoria: 'expresiones', archivo: 'mayo' },
            'mayor': { categoria: 'personas', archivo: 'mayor' },
            'mayor de edad': { categoria: 'personas', archivo: 'mayor de edad' },
            'ma√±ana': { categoria: 'tiempo', archivo: 'ma√±ana' },
            'ma√±anita': { categoria: 'tiempo', archivo: 'ma√±ana' },
            'media hora': { categoria: 'general', archivo: 'media hora' },
            'medico': { categoria: 'profesiones', archivo: 'medico' },
            'medicos': { categoria: 'profesiones', archivo: 'medico' },
            'menor de edad': { categoria: 'personas', archivo: 'menor de edad' },
            'mensajero': { categoria: 'profesiones', archivo: 'mensajero' },
            'mensajeros': { categoria: 'profesiones', archivo: 'mensajero' },
            'mes': { categoria: 'tiempo', archivo: 'mes' },
            'mesonero': { categoria: 'profesiones', archivo: 'mesonero' },
            'mesoneros': { categoria: 'profesiones', archivo: 'mesonero' },
            'miercoles': { categoria: 'dias_semana', archivo: 'miercoles' },
            'mio': { categoria: 'pronombres', archivo: 'mio' },
            'muchas gracias': { categoria: 'cortesia', archivo: 'muchas gracias' },
            'mucho': { categoria: 'preposiciones', archivo: 'mucho' },
            'mucho gusto': { categoria: 'cortesia', archivo: 'mucho gusto' },
            'mujer': { categoria: 'personas', archivo: 'mujer' },
            'n': { categoria: 'alfabeto', archivo: 'n' },
            'nada': { categoria: 'preposiciones', archivo: 'nada' },
            'nadie': { categoria: 'preposiciones', archivo: 'nadie' },
            'ningun': { categoria: 'preposiciones', archivo: 'ningun' },
            'ni√±o': { categoria: 'personas', archivo: 'ni√±o' },
            'no': { categoria: 'expresiones', archivo: 'no' },
            'nosotros': { categoria: 'pronombres', archivo: 'nosotros' },
            'noviembre': { categoria: 'expresiones', archivo: 'noviembre' },
            'novio': { categoria: 'personas', archivo: 'novio' },
            'nuestro': { categoria: 'pronombres', archivo: 'nuestro' },
            'o': { categoria: 'alfabeto', archivo: 'o' },
            'octubre': { categoria: 'expresiones', archivo: 'octubre' },
            'otro': { categoria: 'preposiciones', archivo: 'otro' },
            'oyente': { categoria: 'personas', archivo: 'oyente' },
            'p': { categoria: 'alfabeto', archivo: 'p' },
            'pasado ma√±ana': { categoria: 'tiempo', archivo: 'pasado ma√±ana' },
            'pasante': { categoria: 'profesiones', archivo: 'pasante' },
            'pasantes': { categoria: 'profesiones', archivo: 'pasante' },
            'pelear': { categoria: 'verbos', archivo: 'pelear' },
            'peluquera': { categoria: 'profesiones', archivo: 'peluquera' },
            'peluqueras': { categoria: 'profesiones', archivo: 'peluquera' },
            'permiso': { categoria: 'cortesia', archivo: 'permiso' },
            'persona': { categoria: 'personas', archivo: 'persona' },
            'personas': { categoria: 'personas', archivo: 'personas' },
            'pintor': { categoria: 'profesiones', archivo: 'pintor' },
            'pintors': { categoria: 'profesiones', archivo: 'pintor' },
            'piso': { categoria: 'viviendas', archivo: 'piso' },
            'poco': { categoria: 'preposiciones', archivo: 'poco' },
            'policia': { categoria: 'profesiones', archivo: 'policia' },
            'policias': { categoria: 'profesiones', archivo: 'policia' },
            'porque': { categoria: 'expresiones', archivo: 'porque' },
            'preguntar': { categoria: 'verbos', archivo: 'preguntar' },
            'presentar': { categoria: 'verbos', archivo: 'presentar' },
            'profe': { categoria: 'profesiones', archivo: 'profesor' },
            'profesion': { categoria: 'profesiones', archivo: 'profesion' },
            'profesions': { categoria: 'profesiones', archivo: 'profesion' },
            'profesor': { categoria: 'profesiones', archivo: 'profesor' },
            'profesors': { categoria: 'profesiones', archivo: 'profesor' },
            'psicologo': { categoria: 'profesiones', archivo: 'psicologo' },
            'psicologos': { categoria: 'profesiones', archivo: 'psicologo' },
            'q': { categoria: 'alfabeto', archivo: 'q' },
            'que': { categoria: 'expresiones', archivo: 'que' },
            'que tal': { categoria: 'interrogantes', archivo: 'que tal' },
            'querer': { categoria: 'verbos', archivo: 'querer' },
            'quien': { categoria: 'expresiones', archivo: 'quien' },
            'quienquiera': { categoria: 'preposiciones', archivo: 'quienquiera' },
            'r': { categoria: 'alfabeto', archivo: 'r' },
            'rancho': { categoria: 'viviendas', archivo: 'rancho' },
            'regalar': { categoria: 'verbos', archivo: 'regalar' },
            'regular': { categoria: 'expresiones', archivo: 'regular' },
            'responder': { categoria: 'verbos', archivo: 'responder' },
            's': { categoria: 'alfabeto', archivo: 's' },
            'sabado': { categoria: 'dias_semana', archivo: 'sabado' },
            'sala': { categoria: 'viviendas', archivo: 'sala' },
            'saludar': { categoria: 'verbos', archivo: 'saludar' },
            'saludas a': { categoria: 'expresiones', archivo: 'saludas a' },
            'secretaria': { categoria: 'profesiones', archivo: 'secretaria' },
            'secretarias': { categoria: 'profesiones', archivo: 'secretaria' },
            'semana': { categoria: 'tiempo', archivo: 'semana' },
            'sentir': { categoria: 'verbos', archivo: 'sentir' },
            'separado': { categoria: 'estado_civil', archivo: 'separado' },
            'septiembre': { categoria: 'expresiones', archivo: 'septiembre' },
            'ser': { categoria: 'verbos', archivo: 'ser' },
            'se√±or': { categoria: 'personas', archivo: 'se√±or' },
            'se√±orita': { categoria: 'personas', archivo: 'se√±orita' },
            'si': { categoria: 'expresiones', archivo: 'si' },
            'sistema': { categoria: 'profesiones', archivo: 'sistema' },
            'sistemas': { categoria: 'profesiones', archivo: 'sistema' },
            'soltero': { categoria: 'estado_civil', archivo: 'soltero' },
            'sordo': { categoria: 'personas', archivo: 'sordo' },
            'sordociego': { categoria: 'personas', archivo: 'sordociego' },
            'sufrir': { categoria: 'verbos', archivo: 'sufrir' },
            'supervisor': { categoria: 'profesiones', archivo: 'supervisor' },
            'supervisors': { categoria: 'profesiones', archivo: 'supervisor' },
            'suyo': { categoria: 'pronombres', archivo: 'suyo' },
            't': { categoria: 'alfabeto', archivo: 't' },
            'tecnico': { categoria: 'profesiones', archivo: 'tecnico' },
            'tecnicos': { categoria: 'profesiones', archivo: 'tecnico' },
            'todo': { categoria: 'preposiciones', archivo: 'todo' },
            'trabajar': { categoria: 'verbos', archivo: 'trabajar' },
            'traductor': { categoria: 'profesiones', archivo: 'traductor' },
            'traductors': { categoria: 'profesiones', archivo: 'traductor' },
            'traer': { categoria: 'verbos', archivo: 'traer' },
            'tu': { categoria: 'pronombres', archivo: 'tu' },
            'tuyo': { categoria: 'pronombres', archivo: 'tuyo' },
            'u': { categoria: 'alfabeto', archivo: 'u' },
            'un cuarto': { categoria: 'general', archivo: 'un cuarto' },
            'un minuto': { categoria: 'general', archivo: 'un minuto' },
            'un segundo': { categoria: 'general', archivo: 'un segundo' },
            'una hora': { categoria: 'general', archivo: 'una hora' },
            'usar': { categoria: 'verbos', archivo: 'usar' },
            'ustedes': { categoria: 'pronombres', archivo: 'ustedes' },
            'v': { categoria: 'alfabeto', archivo: 'v' },
            'vendedor': { categoria: 'profesiones', archivo: 'vendedor' },
            'vendedors': { categoria: 'profesiones', archivo: 'vendedor' },
            'ver': { categoria: 'verbos', archivo: 'ver' },
            'verbo': { categoria: 'verbos', archivo: 'verbo' },
            'vestir': { categoria: 'verbos', archivo: 'vestir' },
            'viejo': { categoria: 'personas', archivo: 'viejo' },
            'viernes': { categoria: 'dias_semana', archivo: 'viernes' },
            'vigilante': { categoria: 'profesiones', archivo: 'vigilante' },
            'vigilantes': { categoria: 'profesiones', archivo: 'vigilante' },
            'viudo': { categoria: 'estado_civil', archivo: 'viudo' },
            'vivir': { categoria: 'verbos', archivo: 'vivir' },
            'w': { categoria: 'alfabeto', archivo: 'w' },
            'x': { categoria: 'alfabeto', archivo: 'x' },
            'y': { categoria: 'alfabeto', archivo: 'y' },
            'yo': { categoria: 'pronombres', archivo: 'yo' },
            'z': { categoria: 'alfabeto', archivo: 'z' },
            '√±': { categoria: 'alfabeto', archivo: '√±' },
            'defensa': { categoria: 'frase', archivo: 'defensa' },
            'trabajo': { categoria: 'general', archivo: 'trabajo' },
            'especial': { categoria: 'general', archivo: 'especial' },
            'grado': { categoria: 'general', archivo: 'grado' },
            'aporte': { categoria: 'frase', archivo: 'aportar' },
            'tecnologico': { categoria: 'frase', archivo: 'computadora' },
            'tecnologia': { categoria: 'frase', archivo: 'computadora' },
            'integracion': { categoria: 'frase', archivo: 'integrar' },
            'comunidad': { categoria: 'personas', archivo: 'personas' },
            'un': { categoria: 'numero', archivo: '1' },
            'integrar': { categoria: 'frase', archivo: 'integrar' },
            'venezuela': { categoria: 'frase', archivo: 'venezuela' },
            'venezolano': { categoria: 'general', archivo: 'venezolano' },
            'miembro': { categoria: 'frase', archivo: 'miembros' },
            'miembros': { categoria: 'frase', archivo: 'miembros' },
            'jurado': { categoria: 'profesion', archivo: 'abogado' },
            'presentacion': { categoria: 'frase', archivo: 'nuevo' },
            'traduccion': { categoria: 'frase', archivo: 'traduccion' },
            'traducir': { categoria: 'verbos', archivo: 'traducir' },
            'universidad': { categoria: 'frase', archivo: 'universidad' },
            // üìå Nuevas palabras de carpeta frase (Duvall)
            'entender': { categoria: 'frase', archivo: 'entender' },
            'computadora': { categoria: 'frase', archivo: 'computadora' },
            'dar': { categoria: 'frase', archivo: 'dar' },
            'mejorar': { categoria: 'frase', archivo: 'mejorar' },
            'poder': { categoria: 'frase', archivo: 'poder' },
            'aprender': { categoria: 'frase', archivo: 'aprender' },
            'aportar': { categoria: 'frase', archivo: 'aportar' },
            'nuevo': { categoria: 'frase', archivo: 'nuevo' },
            'nueva': { categoria: 'frase', archivo: 'nuevo' },
            // üìå Sin√≥nimos y mapeos a glosa LSV
            'ahora': { categoria: 'tiempo', archivo: 'hoy' },
            'podemos': { categoria: 'frase', archivo: 'poder' },
            'entendernos': { categoria: 'frase', archivo: 'aprender' },
            'mejor': { categoria: 'frase', archivo: 'mejorar' },
            'bienvenidos': { categoria: 'saludos', archivo: 'bienvenido' },
            'sorda': { categoria: 'personas', archivo: 'sordo' },
            'venezolana': { categoria: 'frase', archivo: 'venezuela' },
            // üìå Palabras de carpeta NUEVO (familia, verbos, operaciones)
            'abuelo': { categoria: 'nuevo', archivo: 'abuelo' },
            'antes': { categoria: 'nuevo', archivo: 'antes' },
            'correr': { categoria: 'nuevo', archivo: 'correr' },
            'cunado': { categoria: 'nuevo', archivo: 'cunado' },
            'cu√±ado': { categoria: 'nuevo', archivo: 'cunado' },
            'dividir': { categoria: 'nuevo', archivo: 'dividir' },
            'entrar': { categoria: 'nuevo', archivo: 'entrar' },
            'familia': { categoria: 'nuevo', archivo: 'familia' },
            'fumar': { categoria: 'nuevo', archivo: 'fumar' },
            'habia una vez': { categoria: 'nuevo', archivo: 'habia una vez' },
            'hab√≠a una vez': { categoria: 'nuevo', archivo: 'habia una vez' },
            'hace rato': { categoria: 'nuevo', archivo: 'hace rato' },
            'hermano': { categoria: 'nuevo', archivo: 'hermano' },
            'hijo': { categoria: 'nuevo', archivo: 'hijo' },
            'madre': { categoria: 'nuevo', archivo: 'madre' },
            'mama': { categoria: 'nuevo', archivo: 'mama' },
            'mam√°': { categoria: 'nuevo', archivo: 'mama' },
            'multiplicar': { categoria: 'nuevo', archivo: 'multiplicar' },
            'nieto': { categoria: 'nuevo', archivo: 'nieto' },
            'nombre': { categoria: 'nuevo', archivo: 'nombre' },
            'padre': { categoria: 'nuevo', archivo: 'padre' },
            'padrino': { categoria: 'nuevo', archivo: 'padrino' },
            'madrina': { categoria: 'nuevo', archivo: 'madrina' },
            'papa': { categoria: 'nuevo', archivo: 'papa' },
            'pap√°': { categoria: 'nuevo', archivo: 'papa' },
            'permitir': { categoria: 'nuevo', archivo: 'permitir' },
            'primo': { categoria: 'nuevo', archivo: 'primo' },
            'prohibir': { categoria: 'nuevo', archivo: 'prohibir' },
            'respetar': { categoria: 'nuevo', archivo: 'respetar' },
            'restar': { categoria: 'nuevo', archivo: 'restar' },
            'sena': { categoria: 'nuevo', archivo: 'sena' },
            'se√±a': { categoria: 'nuevo', archivo: 'sena' },
            'se√±as': { categoria: 'nuevo', archivo: 'sena' },
            'sobrino': { categoria: 'nuevo', archivo: 'sobrino' },
            'stro': { categoria: 'nuevo', archivo: 'stro' },
            'nuestro': { categoria: 'nuevo', archivo: 'stro' },
            'suegro': { categoria: 'nuevo', archivo: 'suegro' },
            'sumar': { categoria: 'nuevo', archivo: 'sumar' },
            'tio': { categoria: 'nuevo', archivo: 'tio' },
            't√≠o': { categoria: 'nuevo', archivo: 'tio' },
            'viajar': { categoria: 'nuevo', archivo: 'viajar' }
        };

        // ÔøΩ PALABRAS FUNCIONALES OMITIDAS (art√≠culos, preposiciones, etc. que no se usan en LSV)
        const PALABRAS_OMITIR_DUPLICADO = new Set([
            'el', 'la', 'los', 'las', 'un', 'una', 'unos', 'unas',
            'a', 'ante', 'bajo', 'con', 'contra', 'desde', 'durante', 'en', 'entre', 'hacia', 'hasta', 'para', 'por', 'segun', 'sin', 'sobre', 'tras',
            'al', 'del',
            'y', 'e', 'o', 'u', 'ni',
            'esta', 'este', 'ese', 'esa', 'aquel', 'aquella',
            'estos', 'estas', 'esos', 'esas', 'aquellos', 'aquellas'
        ]);

        // ÔøΩüóÇÔ∏è MAPEO DE CATEGOR√çAS: Diccionario ‚Üí Carpetas Duvall
        // Las categor√≠as en el diccionario no siempre coinciden con los nombres de carpetas
        const MAPEO_CATEGORIAS = {
            // Categor√≠as con una sola carpeta
            'alfabeto': ['alfabeto'],
            'numero': ['numero'],
            'expresiones': ['expresiones'],
            'cortesia': ['cortesia'],
            'saludos': ['saludos'],
            'personas': ['personas'],
            'pronombres': ['pronombres'],
            'ordinales': ['numeros ordinales'],
            'profesion': ['profesion'],           // Categor√≠a singular
            'profesiones': ['profesion'],
            'adverbios': ['adverbios lugares'],
            'lugares': ['adverbios lugares'],
            'viviendas': ['tipos de vivienda'],
            'estado_civil': ['estado civil'],
            'interrogantes': ['preguntas'],
            'preguntas': ['preguntas'],
            'preposiciones': ['preposicion'],
            'dias_semana': ['dias_semana'],
            'transporte': ['medios transporte'],
            'frase': ['frase'],                   // Palabras completas de carpeta frase
            'nuevo': ['nuevo'],                   // Carpeta nuevo: familia, verbos, operaciones
            
            // Categor√≠as con archivos en M√öLTIPLES carpetas
            'verbos': ['verbos', 'nuevo'],        // Mayor√≠a en verbos, algunos en nuevo
            'tiempo': ['tiempo', 'nuevo'],        // Mayor√≠a en tiempo, algunos en nuevo
            'general': ['horario', 'nuevo'],      // Algunos en horario, algunos en nuevo
            'familia': ['nuevo']                  // TODAS en nuevo
        };

        // Funci√≥n para obtener las carpetas donde buscar archivos de una categor√≠a
        // Ahora retorna ARRAY de carpetas (algunas categor√≠as tienen archivos en m√∫ltiples ubicaciones)
        function obtenerCarpetas(categoria) {
            const carpetas = MAPEO_CATEGORIAS[categoria];
            if (carpetas) {
                return Array.isArray(carpetas) ? carpetas : [carpetas];
            }
            // Si no hay mapeo, retornar categoria original como fallback
            return [categoria];
        }

        // Funci√≥n helper para cargar GLB intentando m√∫ltiples carpetas
        async function cargarGLBDesdeCarpetas(loader, categoria, archivo, avatarActual) {
            // L√ìGICA UNIFICADA: Usar sistema de fallback inteligente
            // Si Carla no tiene un archivo, Duvall SIEMPRE funciona como respaldo
            
            const carpetas = obtenerCarpetas(categoria);
            let ultimoError = null;
            
            console.log(`üîç cargarGLBDesdeCarpetas: avatar="${avatarActual}", categoria="${categoria}", archivo="${archivo}"`);
            logToExpo(`üîç Buscando GLB`, { avatar: avatarActual, categoria, archivo, carpetas: carpetas.join(',') });
            
            // ‚≠ê FALLBACK INTELIGENTE PARA FRASE: SIEMPRE usar Duvall como respaldo (funciona perfectamente)
            // Orden de b√∫squeda: [AvatarActual, Duvall, Luis]
            // Duvall tiene la biblioteca m√°s completa y confiable de animaciones
            const avataresFrase = ['Carla', 'Duvall', 'Luis'];
            let avatarsToTry = [avatarActual];
            
            if (categoria === 'frase') {
                // Para TODAS las palabras de frase, hacer fallback a Duvall si avatar actual falla
                avatarsToTry = [avatarActual, 'Duvall', 'Luis'];
                console.log(`‚ú® Categor√≠a FRASE: Fallback autom√°tico a Duvall ‚Üí Luis`);
                logToExpo(`‚ú® Fallback: ${avatarActual} ‚Üí Duvall ‚Üí Luis`);
            }
            
            // Intentar cargar de cada avatar posible
            for (const avatarPrueba of avatarsToTry) {
                // Intentar cargar de cada carpeta posible
                for (const carpetaCategoria of carpetas) {
                    const timestamp = Date.now(); // Evitar cache del navegador
                    const rutaCompleta = `output/glb/${avatarPrueba}/${carpetaCategoria}/${avatarPrueba}_resultado_${archivo}.glb?t=${timestamp}`;
                    
                    console.log(`üåê Intentando cargar: ${rutaCompleta}`);
                    logToExpo(`üåê URL: ${rutaCompleta}`);
                
                try {
                    const gltf = await new Promise((resolve, reject) => {
                        const timeoutId = setTimeout(() => reject(new Error('Timeout')), GLB_LOAD_TIMEOUT);
                        loader.load(
                            rutaCompleta,
                            (result) => { clearTimeout(timeoutId); resolve(result); },
                            undefined,
                            (error) => { clearTimeout(timeoutId); reject(error); }
                        );
                    });
                    
                    // Si llegamos aqu√≠, la carga fue exitosa
                    console.log(`‚úÖ GLB cargado desde: ${carpetaCategoria} (avatar: ${avatarPrueba})`);
                    logToExpo(`‚úÖ Carga exitosa: ${carpetaCategoria}/${avatarPrueba}`);
                    return { gltf, rutaCompleta };
                    
                } catch (error) {
                    console.error(`‚ùå Fallo en ${avatarPrueba}/${carpetaCategoria}:`, error.message);
                    logToExpo(`‚ùå Fallo: ${avatarPrueba}/${carpetaCategoria} - ${error.message}`);
                    ultimoError = error;
                    // Continuar con la siguiente carpeta/avatar
                }
            }
        }
            
            // Si llegamos aqu√≠, ninguna carpeta funcion√≥
            throw ultimoError || new Error(`No se encontr√≥ GLB en ninguna carpeta: ${carpetas.join(', ')}`);
        }

        // Exponer funci√≥n para React Native
        window.animarPalabras = async function(texto, avatar = 'Nancy') {
            if (avatar !== avatarActual) {
                await cargarAvatar(avatar);
            }
            await traducirYAnimar(texto);
        };

        async function init() {
            // Obtener par√°metros desde URL
            const params = new URLSearchParams(window.location.search);
            const avatarParam = params.get('avatar') || 'Nancy';
            const textoParam = params.get('text') || '';
            
            // ‚ö°‚ö°‚ö° CARGA INSTANT√ÅNEA: Ocultar loading INMEDIATAMENTE
            const loadingDiv = document.getElementById('loading');
            if (loadingDiv) {
                loadingDiv.classList.add('hidden');
            }
            
            // ‚ö°‚ö°‚ö° NOTIFICAR INSTANT√ÅNEAMENTE que est√° listo (0ms)
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify({
                    type: 'pageReady',
                    message: 'Traductor listo',
                    avatar: avatarParam
                }));
                console.log('‚ö° Notificado INMEDIATAMENTE - carga instant√°nea');
            }
            
            // Todo lo dem√°s se carga despu√©s en segundo plano
            setTimeout(async () => {
                setupScene();
                setupControls();
                
                // Crear instancia √∫nica de loader
                loaderInstance = new GLTFLoader();
                
                // Iniciar loop de animaci√≥n
                animate();
                
                // Inicializar IndexedDB en segundo plano
                initIndexedDB().catch(err => console.warn('IndexedDB init error:', err));
                
                // Cargar avatar en segundo plano
                cargarAvatar(avatarParam).then(() => {
                    console.log('‚úÖ Avatar cargado completamente');
                    
                    if (window.ReactNativeWebView) {
                        window.ReactNativeWebView.postMessage(JSON.stringify({
                            type: 'avatarReady',
                            message: 'Avatar cargado',
                            avatar: avatarParam
                        }));
                    }
                }).catch(error => {
                    console.error('‚ùå Error cargando avatar:', error);
                });
                
                // OPTIMIZACI√ìN M√ìVIL: lazy loading
                if (!isMobile) {
                    precargarAnimacionesComunes();
                } else {
                    console.log('üì± Modo m√≥vil: lazy loading activado');
                    logToExpo('üì± Lazy loading activo');
                }
                
                // Si hay texto en URL, animarlo
                if (textoParam) {
                    document.getElementById('textInput').value = textoParam;
                    setTimeout(() => {
                        traducirYAnimar(textoParam);
                    }, 1500);
                }
            }, 10); // Micro delay de 10ms para permitir que la notificaci√≥n llegue primero
        }

        function setupControls() {
            const textInput = document.getElementById('textInput');
            const animateBtn = document.getElementById('animateBtn');
            const pauseBtn = document.getElementById('pauseBtn');
            const replayBtn = document.getElementById('replayBtn');
            const resetCameraBtn = document.getElementById('resetCameraBtn');

            // Bot√≥n Animar
            animateBtn.addEventListener('click', () => {
                const texto = textInput.value.trim();
                console.log('üîò Bot√≥n ANIMAR clickeado', { texto, isAnimating });
                logToExpo('üîò Bot√≥n ANIMAR presionado', { texto, isAnimating });
                
                if (texto && !isAnimating) {
                    console.log('‚úÖ Iniciando traducci√≥n y animaci√≥n...');
                    traducirYAnimar(texto);
                } else {
                    console.log('‚ö†Ô∏è No se puede animar:', { razon: !texto ? 'Texto vac√≠o' : 'Ya animando' });
                    logToExpo('‚ö†Ô∏è Animaci√≥n bloqueada', { razon: !texto ? 'Texto vac√≠o' : 'Ya animando' });
                }
            });

            // Enter en el input
            textInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const texto = textInput.value.trim();
                    console.log('‚å®Ô∏è Enter presionado', { texto, isAnimating });
                    logToExpo('‚å®Ô∏è Enter en input', { texto, isAnimating });
                    
                    if (texto && !isAnimating) {
                        console.log('‚úÖ Iniciando traducci√≥n y animaci√≥n...');
                        traducirYAnimar(texto);
                    } else {
                        console.log('‚ö†Ô∏è No se puede animar:', { razon: !texto ? 'Texto vac√≠o' : 'Ya animando' });
                        logToExpo('‚ö†Ô∏è Animaci√≥n bloqueada', { razon: !texto ? 'Texto vac√≠o' : 'Ya animando' });
                    }
                }
            });

            // Bot√≥n Pausar/Reanudar
            pauseBtn.addEventListener('click', () => {
                if (!currentAction) return;

                isPaused = !isPaused;
                
                if (isPaused) {
                    currentAction.paused = true;
                    pauseBtn.classList.add('paused');
                    document.getElementById('pauseIcon').textContent = '‚ñ∂Ô∏è';
                    document.getElementById('pauseText').textContent = 'Reanudar';
                    updateStatus('‚è∏Ô∏è Pausado', false);
                } else {
                    currentAction.paused = false;
                    pauseBtn.classList.remove('paused');
                    document.getElementById('pauseIcon').textContent = '‚è∏Ô∏è';
                    document.getElementById('pauseText').textContent = 'Pausar';
                    updateStatus(`‚ñ∂Ô∏è ${ultimoTexto}`, false);
                }
            });

            // Bot√≥n Repetir
            replayBtn.addEventListener('click', () => {
                if (ultimoTexto && !isAnimating) {
                    traducirYAnimar(ultimoTexto);
                }
            });
            
            // Bot√≥n Resetear C√°mara
            resetCameraBtn.addEventListener('click', () => {
                resetCamera();
            });
            
            console.log('ü§ñ Modo API activado permanentemente - Correcci√≥n con IA');
        }
        
        function resetCamera() {
            if (!camera || !controls) return;
            
            // SOLUCI√ìN: Deshabilitar OrbitControls durante el reset para evitar interferencia
            controls.enabled = false;
            
            const startPos = camera.position.clone();
            const startTarget = controls.target.clone();
            const duration = 800; // ms
            const startTime = Date.now();
            
            // Valores objetivo fijos (nunca cambian)
            const targetPosX = INITIAL_CAMERA_POSITION.x;
            const targetPosY = INITIAL_CAMERA_POSITION.y;
            const targetPosZ = INITIAL_CAMERA_POSITION.z;
            const targetLookX = INITIAL_CAMERA_TARGET.x;
            const targetLookY = INITIAL_CAMERA_TARGET.y;
            const targetLookZ = INITIAL_CAMERA_TARGET.z;
            
            function animateCameraReset() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing suave (ease-out)
                const eased = 1 - Math.pow(1 - progress, 3);
                
                // Interpolar hacia valores ABSOLUTOS (no acumulativos)
                camera.position.x = startPos.x + (targetPosX - startPos.x) * eased;
                camera.position.y = startPos.y + (targetPosY - startPos.y) * eased;
                camera.position.z = startPos.z + (targetPosZ - startPos.z) * eased;
                
                controls.target.x = startTarget.x + (targetLookX - startTarget.x) * eased;
                controls.target.y = startTarget.y + (targetLookY - startTarget.y) * eased;
                controls.target.z = startTarget.z + (targetLookZ - startTarget.z) * eased;
                
                if (progress < 1) {
                    requestAnimationFrame(animateCameraReset);
                } else {
                    // Forzar valores exactos al final
                    camera.position.set(targetPosX, targetPosY, targetPosZ);
                    controls.target.set(targetLookX, targetLookY, targetLookZ);
                    
                    // Reactivar OrbitControls despu√©s del reset
                    controls.enabled = true;
                    controls.update();
                    
                    console.log('üéØ C√°mara reseteada a posici√≥n inicial');
                }
            }
            
            animateCameraReset();
        }

        function setupScene() {
            const container = document.getElementById('viewer-container');
            const canvas = document.getElementById('canvas-3d');
            
            scene = new THREE.Scene();
            //color de fondo
            scene.background = new THREE.Color(0xffffff);
            
            camera = new THREE.PerspectiveCamera(
                50,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(INITIAL_CAMERA_POSITION.x, INITIAL_CAMERA_POSITION.y, INITIAL_CAMERA_POSITION.z);
            
            // Renderer con CALIDAD M√ÅXIMA + RENDIMIENTO √ìPTIMO
            const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true, // ‚ú® SIEMPRE activado - bordes suaves y alta calidad
                alpha: true
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            
            // ‚ö° BALANCE PERFECTO: Limitar pixelRatio a 2.0 m√°ximo
            // Pantallas 1x: usa 1.0 | Pantallas 2x: usa 2.0 | Pantallas 3x/4x: usa 2.0
            // Ahorra 50% rendimiento en pantallas ultra-densas SIN p√©rdida visual
            const pixelRatio = Math.min(window.devicePixelRatio, 2.0);
            renderer.setPixelRatio(pixelRatio);
            
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            
            // ‚ú® BRILLO Y CALIDAD: Tone mapping SIEMPRE activado
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            
            console.log('‚úÖ Renderer: CALIDAD ALTA + RENDIMIENTO EXCELENTE');
            console.log(`üì± Dispositivo: ${isMobile ? 'M√≥vil' : 'Escritorio'}`);
            console.log(`üé® PixelRatio: ${pixelRatio.toFixed(2)} (dispositivo: ${window.devicePixelRatio})`);
            console.log(`‚ú® Antialias: ACTIVADO | Tone Mapping: ACTIVADO`);
            
            controls = new OrbitControls(camera, canvas);
            controls.target.set(INITIAL_CAMERA_TARGET.x, INITIAL_CAMERA_TARGET.y, INITIAL_CAMERA_TARGET.z);
            controls.update();
            
            // Sistema de iluminaci√≥n igual que avatar_static.html
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight1.position.set(5, 5, 5);
            scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight2.position.set(-5, 3, -5);
            scene.add(directionalLight2);
            
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
            fillLight.position.set(0, -2, 5);
            scene.add(fillLight);
            
            clock = new THREE.Clock();
            
            // LOGGING INICIAL - Posici√≥n al iniciar
            logToExpo('üü¢ C√ÅMARA INICIAL:', {
                position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                target: { x: controls.target.x, y: controls.target.y, z: controls.target.z },
                zoom: camera.zoom,
                fov: camera.fov
            });
            
            // Mejorado: Detectar teclado virtual y CONGELAR controles completamente
            window.addEventListener('resize', () => {
                const currentHeight = window.innerHeight;
                const currentWidth = window.innerWidth;
                const heightDifference = initialViewportHeight - currentHeight;
                
                logToExpo('üìè RESIZE DETECTADO:', {
                    initialHeight: initialViewportHeight,
                    currentHeight: currentHeight,
                    currentWidth: currentWidth,
                    difference: heightDifference,
                    aspect: currentWidth / currentHeight,
                    isKeyboardOpen: isKeyboardOpen
                });
                
                // Detectar si el teclado virtual se abri√≥ (altura reducida significativamente)
                if (heightDifference > 150 && !isKeyboardOpen) {
                    // Teclado abierto
                    isKeyboardOpen = true;
                    
                    // Guardar estado actual de la c√°mara
                    if (camera && controls) {
                        savedCameraState = {
                            position: camera.position.clone(),
                            target: controls.target.clone(),
                            zoom: camera.zoom,
                            fov: camera.fov
                        };
                        
                        logToExpo('üî¥ TECLADO ABIERTO - Estado guardado:', {
                            position: { x: savedCameraState.position.x, y: savedCameraState.position.y, z: savedCameraState.position.z },
                            target: { x: savedCameraState.target.x, y: savedCameraState.target.y, z: savedCameraState.target.z },
                            zoom: savedCameraState.zoom,
                            fov: savedCameraState.fov
                        });
                        
                        // CONGELAR OrbitControls completamente
                        controls.enabled = false;
                        logToExpo('‚õî OrbitControls DESHABILITADO');
                    }
                } else if (heightDifference < 100 && isKeyboardOpen) {
                    // Teclado cerrado
                    isKeyboardOpen = false;
                    
                    logToExpo('üü¢ TECLADO CERRADO - Antes de restaurar:', {
                        currentPosition: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                        currentTarget: { x: controls.target.x, y: controls.target.y, z: controls.target.z },
                        currentZoom: camera.zoom,
                        currentFov: camera.fov
                    });
                    
                    // Restaurar posici√≥n exacta de la c√°mara despu√©s de un breve delay
                    setTimeout(() => {
                        if (savedCameraState && camera && controls) {
                            // Restaurar TODOS los valores guardados
                            camera.position.set(
                                savedCameraState.position.x,
                                savedCameraState.position.y,
                                savedCameraState.position.z
                            );
                            controls.target.set(
                                savedCameraState.target.x,
                                savedCameraState.target.y,
                                savedCameraState.target.z
                            );
                            camera.zoom = savedCameraState.zoom;
                            camera.fov = savedCameraState.fov;
                            camera.updateProjectionMatrix();
                            
                            // Reactivar OrbitControls
                            controls.enabled = true;
                            controls.update();
                            
                            logToExpo('‚úÖ C√°mara RESTAURADA:', {
                                restoredPosition: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                                restoredTarget: { x: controls.target.x, y: controls.target.y, z: controls.target.z },
                                restoredZoom: camera.zoom,
                                restoredFov: camera.fov
                            });
                            logToExpo('‚úÖ OrbitControls REACTIVADO');
                        }
                    }, 100);
                }
                
                // NO actualizar aspect ratio ni renderer cuando el input est√° enfocado (savedCameraState existe)
                if (camera && renderer && !savedCameraState) {
                    const container = document.getElementById('viewer-container');
                    const newWidth = container.clientWidth;
                    const newHeight = container.clientHeight;
                    const newAspect = newWidth / newHeight;
                    
                    logToExpo('üìê Calculando nuevo aspect:', {
                        containerWidth: newWidth,
                        containerHeight: newHeight,
                        newAspect: newAspect,
                        currentAspect: camera.aspect,
                        willUpdate: Math.abs(camera.aspect - newAspect) > 0.01
                    });
                    
                    if (Math.abs(camera.aspect - newAspect) > 0.01) {
                        camera.aspect = newAspect;
                        camera.updateProjectionMatrix();
                        logToExpo('üîÑ Aspect ratio actualizado:', { aspect: newAspect });
                    }
                    renderer.setSize(newWidth, newHeight);
                } else if (savedCameraState) {
                    logToExpo('‚è∏Ô∏è Aspect ratio bloqueado (input enfocado)');
                }
            });
            
            // Actualizar altura inicial cuando la p√°gina carga completamente
            window.addEventListener('load', () => {
                initialViewportHeight = window.innerHeight;
                logToExpo('üü¢ Altura inicial establecida:', { height: initialViewportHeight });
            });
        }

        async function cargarAvatar(nombreAvatar) {
            const loadingText = document.getElementById('loading-text');
            const loadingDiv = document.getElementById('loading');
            
            loadingDiv.classList.remove('hidden');
            loadingText.textContent = `Cargando ${nombreAvatar}...`;
            
            // Reutilizar loader si existe, sino crear uno nuevo
            const loader = loaderInstance || new GLTFLoader();
            if (!loaderInstance) loaderInstance = loader;
            
            // Usar rutas desde test/output/glb
            const baseUrl = `output/glb/${nombreAvatar}/`;
            
            // Ruta directa a los avatares en output/glb/{Avatar}/{Avatar}.glb
            const rutasAvatar = [
                `${baseUrl}${nombreAvatar}.glb`  // Local: output/glb/Carla/Carla.glb
            ];
            
            for (const ruta of rutasAvatar) {
                try {
                    const gltf = await new Promise((res, rej) => {
                        loader.load(
                            ruta,
                            (result) => res(result),
                            (progress) => {
                                const percent = (progress.loaded / progress.total) * 100;
                                loadingText.textContent = `Cargando ${nombreAvatar}... ${percent.toFixed(0)}%`;
                            },
                            (error) => rej(error)
                        );
                    });
                    
                    console.log(`‚úÖ Avatar cargado desde: ${ruta}`);
                    
                    if (avatarModel) {
                        // Limpieza eficiente del avatar anterior
                        scene.remove(avatarModel);
                        avatarModel.traverse((child) => {
                            if (child.geometry) {
                                child.geometry.dispose();
                            }
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(m => m.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        });
                    }
                    
                    avatarModel = gltf.scene;
                    scene.add(avatarModel);
                    
                    const box = new THREE.Box3().setFromObject(avatarModel);
                    const center = box.getCenter(new THREE.Vector3());
                    avatarModel.position.sub(center);
                    avatarModel.position.y = 0;
                    
                    // Verificar y habilitar morph targets
                    let morphTargetMeshes = 0;
                    const nodeNameMap = {};
                    
                    avatarModel.traverse((child) => {
                        if (child.isMesh && child.morphTargetInfluences && child.morphTargetInfluences.length > 0) {
                            morphTargetMeshes++;
                            console.log(`üé≠ Morph targets en ${child.name}: ${child.morphTargetInfluences.length}`);
                            
                            // Crear mapping bidireccional de nombres
                            const baseName = child.name.replace(/\.\d+$/, ''); // Quitar sufijos .001, .004, etc
                            
                            // Mapear DESDE nombre base (del GLB) HACIA nombre real (del avatar)
                            nodeNameMap[baseName] = child.name;
                            
                            if (baseName !== child.name) {
                                console.log(`üìù Mapping: ${baseName} ‚Üí ${child.name}`);
                            }
                            
                            // Asegurar que el material actualiza los morph targets
                            if (child.material) {
                                child.material.morphTargets = true;
                                child.material.needsUpdate = true;
                            }
                        }
                    });
                    
                    // Guardar el mapping en el modelo para uso posterior
                    avatarModel.userData.nodeNameMap = nodeNameMap;
                    
                    if (morphTargetMeshes > 0) {
                        console.log(`‚úÖ ${morphTargetMeshes} meshes con morph targets habilitados`);
                    }
                    
                    mixer = new THREE.AnimationMixer(avatarModel);
                    
                    // Limpiar cach√© de animaciones al cambiar avatar
                    animationCache.clear();
                    avatarActual = nombreAvatar;
                    
                    loadingDiv.classList.add('hidden');
                    //cambio
                    //document.getElementById('status').textContent = `‚úÖ ${nombreAvatar} listo`;
                    console.log(`‚úÖ ${nombreAvatar} cargado exitosamente`);
                    return;
                    
                } catch (error) {
                    console.log(`‚ö†Ô∏è No se pudo cargar desde: ${ruta}`);
                }
            }
            
            // Si no se pudo cargar desde ninguna ruta
            console.error(`‚ùå No se pudo cargar ${nombreAvatar} desde ninguna ubicaci√≥n`);
            updateStatus(`‚ùå Error: ${nombreAvatar}`, false);
            loadingDiv.classList.add('hidden');
            throw new Error(`No se pudo cargar ${nombreAvatar}`);
        }

        // Funci√≥n para llamar al backend API
        async function traducirConBackend(texto) {
            try {
                console.log('üåê Llamando a backend API...');
                logToExpo('üìû Iniciando petici√≥n al backend', { texto, backend: BACKEND_URL });
                
                // Crear controlador de abort con timeout de 10 segundos (aumentado para mobile)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    console.log('‚è±Ô∏è Timeout de backend alcanzado (10s)');
                    logToExpo('‚è±Ô∏è Timeout del backend despu√©s de 10s');
                    controller.abort();
                }, 10000);
                
                const response = await fetch(`${BACKEND_URL}/api/translate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        texto: texto,
                        avatar: avatarActual,
                        deletrear_desconocidas: true,
                        corregir_ortografia: true,
                        velocidad_deletreo: 1.2
                    }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);

                if (!response.ok) {
                    throw new Error(`Error HTTP: ${response.status}`);
                }

                const resultado = await response.json();
                
                logToExpo('‚úÖ Backend respondi√≥ exitosamente', { 
                    total: resultado.total_animaciones,
                    glosa: resultado.glosa_lsv 
                });
                
                // Mostrar correcciones si las hay
                if (resultado.correcciones && resultado.correcciones.length > 0) {
                    console.log('‚úèÔ∏è Correcciones aplicadas:');
                    resultado.correcciones.forEach(corr => {
                        console.log(`  "${corr.original}" ‚Üí "${corr.corregida}" (${corr.tipo}, ${corr.confianza}% confianza)`);
                    });
                }
                
                console.log(`üìä Backend: ${resultado.total_animaciones} animaciones generadas`);
                console.log(`üìù Texto corregido: "${resultado.texto_corregido}"`);
                
                return resultado;
                
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.error('‚è±Ô∏è Timeout: El backend no respondi√≥ en 10 segundos');
                    logToExpo('‚è±Ô∏è Timeout: Backend no respondi√≥', { timeout: '10s' });
                } else {
                    console.error('‚ùå Error conectando con backend:', error.message);
                    logToExpo('‚ùå Error del backend', { error: error.message });
                }
                console.log('üîÑ Usando modo local como fallback');
                return null; // Indica que debe usar modo local
            }
        }

        async function traducirYAnimar(texto) {
            // ‚úÖ NORMALIZAR TEXTO AL INICIO para que "d√≠a" ‚Üí "dia", "Jos√©" ‚Üí "jose", etc.
            texto = normalizarTextoEspanol(texto);
            
            // ‚úÖ LIMPIAR PUNTUACI√ìN (¬ø?¬°!,.;:-())
            texto = texto.replace(/[¬ø?¬°!,.:;()\-\"\']/g, ' ').replace(/\s+/g, ' ').trim();
            
            console.log('üé¨ traducirYAnimar() llamada', { texto, isAnimating });
            logToExpo('üé¨ Funci√≥n traducirYAnimar iniciada', { texto, isAnimating });
            
            if (isAnimating) {
                console.log('‚ö†Ô∏è Ya hay una animaci√≥n en curso, retornando');
                logToExpo('‚ö†Ô∏è Animaci√≥n bloqueada: ya hay una en curso');
                return;
            }
            
            isAnimating = true;
            ultimoTexto = texto;
            isPaused = false;
            
            console.log('‚úÖ Estado actualizado', { isAnimating: true, texto });
            
            // Habilitar controles
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('replayBtn').disabled = false;
            document.getElementById('animateBtn').disabled = true;
            
            let animacionesValidas = [];
            
            // Si est√° activado el modo API, intentar usar backend
            if (useBackendAPI) {
                const resultadoBackend = await traducirConBackend(texto);
                
                if (resultadoBackend && resultadoBackend.animaciones) {
                    console.log('üéØ Backend respondi√≥ con animaciones');
                    logToExpo('üéØ Usando animaciones del backend', { 
                        cantidad: resultadoBackend.animaciones.length,
                        nombres: resultadoBackend.animaciones.map(a => a.nombre).join(', ')
                    });
                    
                    // El backend YA devuelve las frases combinadas correctamente
                    // Los nombres YA vienen normalizados (sin tildes pero con √±) - NO normalizar de nuevo
                    animacionesValidas = resultadoBackend.animaciones.map(anim => ({
                        texto: anim.nombre,
                        // Usar nombre directamente del backend (ya normalizado correctamente)
                        palabra: anim.nombre.toLowerCase(),
                        // Incluir categoria y archivo del backend
                        categoria: anim.categoria,
                        archivo: anim.archivo
                    }));
                    
                    console.log(`ü§ñ Usando ${animacionesValidas.length} animaciones del backend`);
                    console.log(`üìã Secuencia: ${animacionesValidas.map(a => a.texto).join(' ‚Üí ')}`);
                    
                    // Si el backend proces√≥ el texto, saltamos el procesamiento local
                    if (animacionesValidas.length > 0) {
                        // Ir directamente a reproducci√≥n
                        await reproducirSecuencia(animacionesValidas);
                        return;
                    }
                }
                // Si fall√≥ el backend, continuar con modo local
                console.log('‚ö° Procesando localmente...');
                logToExpo('‚ö° Backend fall√≥, usando traductor local', { motivo: !resultadoBackend ? 'Sin respuesta' : 'Sin animaciones' });
            } else {
                // Usar traductor LSV local (GitHub Pages)
                console.log('üìö Usando traductor LSV local...');
                logToExpo('üìö Iniciando traductor LSV local', { texto, lsvDisponible: typeof window.LSV_TRANSLATOR !== 'undefined' });
                
                if (typeof window.LSV_TRANSLATOR !== 'undefined') {
                    console.log('‚úÖ LSV_TRANSLATOR disponible, llamando translate()...');
                    logToExpo('‚úÖ LSV_TRANSLATOR detectado');
                    
                    const resultado = window.LSV_TRANSLATOR.translate(texto, {
                        deletrearDesconocidas: true,
                        velocidadDeletreo: 1.2
                    });
                    
                    console.log('üîç Resultado de translate:', resultado);
                    logToExpo('üîç Resultado LSV', { 
                        animaciones: resultado.animaciones.length,
                        deletreadas: resultado.palabrasDeletreadas.length
                    });
                    
                    if (resultado.palabrasDeletreadas.length > 0) {
                        console.log(`‚úèÔ∏è Palabras deletreadas: ${resultado.palabrasDeletreadas.join(', ')}`);
                        logToExpo(`‚úèÔ∏è Palabras deletreadas: ${resultado.palabrasDeletreadas.join(', ')}`);
                    }
                    
                    animacionesValidas = resultado.animaciones.map(anim => ({
                        texto: anim.archivo,  // Usar archivo (el mapeado: poder, aprender, etc.)
                        palabra: anim.archivo.toLowerCase(),
                        categoria: anim.categoria,  // ‚úÖ AGREGAR categoria
                        archivo: anim.archivo       // ‚úÖ AGREGAR archivo
                    }));
                    
                    console.log(`üéØ LSV: ${resultado.totalAnimaciones} animaciones generadas`);
                    console.log(`üìã Secuencia: ${animacionesValidas.map(a => a.texto).join(' ‚Üí ')}`);
                    
                    if (animacionesValidas.length > 0) {
                        await reproducirSecuencia(animacionesValidas);
                        return;
                    }
                } else {
                    console.error('‚ùå Traductor LSV no disponible');
                    logToExpo('‚ùå LSV_TRANSLATOR no est√° definido - usando fallback');
                }
            }
            
            // Modo local antiguo (fallback si LSV fall√≥)
            console.log('üîÑ Cay√≥ en modo fallback - procesamiento palabra por palabra');
            logToExpo('üîÑ Modo fallback activado', { razon: typeof window.LSV_TRANSLATOR === 'undefined' ? 'LSV no disponible' : 'Sin animaciones de LSV' });
            const palabras = texto.toLowerCase().trim().split(/\s+/);
            
            let i = 0;
            while (i < palabras.length) {
                let encontrada = false;
                
                // Frases de 3 palabras
                if (i + 2 < palabras.length) {
                    const frase3 = palabras.slice(i, i + 3).join(' ');
                    const frase3Normalizada = normalizarPalabra(frase3);
                    
                    // Si la frase debe omitirse (null)
                    if (frase3Normalizada === null) {
                        i++;
                        continue;
                    }
                    
                    // Buscar la frase directamente o normalizada en el diccionario
                    if (DICCIONARIO[frase3Normalizada] || DICCIONARIO[frase3]) {
                        const palabraFinal = DICCIONARIO[frase3Normalizada] ? frase3Normalizada : frase3;
                        animacionesValidas.push({ texto: frase3, palabra: palabraFinal });
                        i += 3;
                        encontrada = true;
                    }
                }
                
                // Frases de 2 palabras
                if (!encontrada && i + 1 < palabras.length) {
                    const frase2 = palabras.slice(i, i + 2).join(' ');
                    const frase2Normalizada = normalizarPalabra(frase2);
                    
                    // Si la frase debe omitirse (null)
                    if (frase2Normalizada === null) {
                        i++;
                        continue;
                    }
                    
                    // Buscar la frase directamente o normalizada en el diccionario
                    if (DICCIONARIO[frase2Normalizada] || DICCIONARIO[frase2]) {
                        const palabraFinal = DICCIONARIO[frase2Normalizada] ? frase2Normalizada : frase2;
                        animacionesValidas.push({ texto: frase2, palabra: palabraFinal });
                        i += 2;
                        encontrada = true;
                    }
                }
                
                // Palabra individual
                if (!encontrada) {
                    const palabraNormalizada = normalizarPalabra(palabras[i]);
                    
                    // Si la palabra debe omitirse (null)
                    if (palabraNormalizada === null) {
                        console.log(`‚äò Omitida: "${palabras[i]}" (no se usa en LSV)`);
                        i++;
                        continue;
                    }
                    
                    // Verificar si es un n√∫mero
                    if (/^\d+$/.test(palabraNormalizada)) {
                        const glosasNumero = numeroAGlosas(palabraNormalizada);
                        if (glosasNumero) {
                            console.log(`üî¢ N√∫mero: "${palabraNormalizada}" ‚Üí ${glosasNumero.join(' ')}`);
                            // Agregar cada glosa del n√∫mero
                            for (const glosa of glosasNumero) {
                                if (DICCIONARIO[glosa]) {
                                    animacionesValidas.push({ texto: glosa, palabra: glosa });
                                } else {
                                    console.warn(`‚ö†Ô∏è Glosa num√©rica no encontrada: ${glosa}`);
                                }
                            }
                            i++;
                            continue;
                        }
                    }
                    
                    if (DICCIONARIO[palabraNormalizada]) {
                        // Palabra encontrada (puede ser normalizada o no)
                        if (palabraNormalizada !== palabras[i]) {
                            console.log(`üîÑ Normalizada: "${palabras[i]}" ‚Üí "${palabraNormalizada}"`);
                        }
                        animacionesValidas.push({ texto: palabras[i], palabra: palabraNormalizada });
                    } else {
                        // Palabra no encontrada - deletrear
                        console.warn(`‚ö†Ô∏è Palabra no encontrada, deletreando: ${palabras[i]}`);
                        
                        // Agregar animaci√≥n de "deletrear"
                        if (DICCIONARIO['deletrear']) {
                            animacionesValidas.push({ texto: 'deletrear', palabra: 'deletrear' });
                        }
                        
                        // Separar la palabra en letras
                        const letras = palabras[i].split('');
                        for (const letra of letras) {
                            const letraLower = letra.toLowerCase();
                            // Normalizar tildes para deletreo (√≠‚Üíi, √°‚Üía, mantiene √±)
                            const letraNormalizada = normalizarTextoEspanol(letraLower);
                            // Verificar si la letra existe en el alfabeto
                            if (DICCIONARIO[letraNormalizada]) {
                                animacionesValidas.push({ texto: letraLower, palabra: letraNormalizada });
                                console.log(`üî§ Deletreando: "${letraLower}" ‚Üí "${letraNormalizada}"`);
                            } else {
                                console.warn(`‚ö†Ô∏è Letra no encontrada en alfabeto: ${letraNormalizada}`);
                            }
                        }
                    }
                    i++;
                }
            }
            
            if (animacionesValidas.length === 0) {
                //cambio
                //document.getElementById('status').textContent = '‚ö†Ô∏è No se encontraron animaciones';
                isAnimating = false;
                document.getElementById('animateBtn').disabled = false;
                return;
            }
            
            await reproducirSecuencia(animacionesValidas);
        }
        
        // Funci√≥n reutilizable para reproducir secuencia de animaciones
        async function reproducirSecuencia(animacionesValidas) {
            console.log(`üé¨ Secuencia: ${animacionesValidas.map(a => a.texto).join(' ‚Üí ')}`);
            console.log(`üéØ Animaciones: ${animacionesValidas.map(a => a.palabra).join(' ‚Üí ')}`);
            
            // Guardar secuencia actual (ahora guarda objetos completos)
            currentSequence = animacionesValidas;
            currentIndex = 0;
            
            // Precargar las primeras animaciones de forma agresiva
            console.log(`üöÄ Iniciando precarga agresiva de primeras ${LOOKAHEAD} animaciones...`);
            precargarSiguientes(0);
            
            // Dar un momento para que la precarga avance (especialmente importante en m√≥vil)
            await new Promise(resolve => setTimeout(resolve, isMobile ? 800 : 400));
            console.log(`‚úÖ Precarga inicial completada, iniciando reproducci√≥n...`);
            
            // Reproducir secuencia sin delays
            for (let idx = 0; idx < animacionesValidas.length; idx++) {
                const animacion = animacionesValidas[idx];
                currentIndex = idx;
                
                // Precargar siguientes mientras reproduce actual (m√°s adelante)
                if (idx + 1 < animacionesValidas.length) {
                    precargarSiguientes(idx + 1);
                }
                
                // Pasar categoria y archivo si vienen del backend
                await cargarYReproducirAnimacion(
                    animacion.palabra, 
                    animacion.categoria, 
                    animacion.archivo
                );
            }
            
            updateStatus('‚úÖ Completado', false);
            isAnimating = false;
            document.getElementById('animateBtn').disabled = false;
            
            // Resetear bot√≥n de pausa a estado inicial (verde)
            const pauseBtn = document.getElementById('pauseBtn');
            pauseBtn.classList.remove('paused');
            document.getElementById('pauseIcon').textContent = '‚è∏Ô∏è';
            document.getElementById('pauseText').textContent = 'Pausar';
        }

        // Funci√≥n para precargar las siguientes N animaciones (MEJORADA)
        function precargarSiguientes(startIdx) {
            const endIdx = Math.min(startIdx + LOOKAHEAD, currentSequence.length);
            
            console.log(`üîÑ Precargando desde √≠ndice ${startIdx} hasta ${endIdx - 1} (LOOKAHEAD: ${LOOKAHEAD})`);
            
            for (let i = startIdx; i < endIdx; i++) {
                const animacion = currentSequence[i];
                const palabra = animacion.palabra;
                // Normalizar palabra para b√∫squeda (mantiene √±)
                const palabraNormalizada = normalizarTextoEspanol(palabra.toLowerCase().trim());
                
                // Si ya est√° en cach√© RAM, continuar
                if (animationCache.has(palabraNormalizada)) {
                    console.log(`‚ö° Ya en cach√©: ${palabraNormalizada}`);
                    continue;
                }
                
                // Prioridad: precargar inmediatamente las pr√≥ximas 2 animaciones
                const esPrioridad = (i - startIdx) < 2;
                
                // Precargar en background sin bloquear
                precargarAnimacionSilenciosa(
                    palabraNormalizada, 
                    animacion.categoria, 
                    animacion.archivo,
                    esPrioridad
                ).catch(err => {
                    console.warn(`‚ö†Ô∏è Fallo precarga ${palabraNormalizada}:`, err.message);
                });
            }
        }
        
        // Precarga silenciosa sin bloquear la ejecuci√≥n - MEJORADA
        async function precargarAnimacionSilenciosa(palabraNormalizada, categoriaBackend = null, archivoBackend = null, esPrioridad = false) {
            // 1. Verificar RAM
            if (animationCache.has(palabraNormalizada)) {
                return;
            }
            
            if (esPrioridad) {
                console.log(`üéØ PRIORIDAD: Precargando ${palabraNormalizada}`);
            }
            
            // 2. Verificar IndexedDB (si ya est√° ah√≠, moverla a RAM)
            const dbKey = `${avatarActual}-${palabraNormalizada}`;
            const clipDataFromDB = await loadAnimationFromDB(dbKey);
            
            if (clipDataFromDB) {
                const clip = deserializeAnimationClip(clipDataFromDB);
                if (animationCache.size >= MAX_CACHE_SIZE) {
                    const firstKey = animationCache.keys().next().value;
                    animationCache.delete(firstKey);
                }
                animationCache.set(palabraNormalizada, clip);
                console.log(`üì¶ Precargada desde DB: ${palabraNormalizada}`);
                return;
            }
            
            // 3. Descargar desde red (solo si no est√° en DB)
            let categoria, archivo;
            if (categoriaBackend && archivoBackend) {
                categoria = categoriaBackend;
                archivo = archivoBackend;
            } else if (DICCIONARIO[palabraNormalizada]) {
                categoria = DICCIONARIO[palabraNormalizada].categoria;
                archivo = DICCIONARIO[palabraNormalizada].archivo;
            } else {
                return;
            }
            
            try {
                const loader = loaderInstance || new GLTFLoader();
                const { gltf } = await cargarGLBDesdeCarpetas(loader, categoria, archivo, avatarActual);
                
                if (gltf.animations && gltf.animations.length > 0) {
                    const clip = gltf.animations[0];
                    procesarTracksAnimacion(clip);
                    
                    // Guardar en RAM
                    if (animationCache.size >= MAX_CACHE_SIZE) {
                        const firstKey = animationCache.keys().next().value;
                        animationCache.delete(firstKey);
                    }
                    animationCache.set(palabraNormalizada, clip);
                    
                    // Guardar en IndexedDB (no esperar, background)
                    const serializedClip = serializeAnimationClip(clip);
                    saveAnimationToDB(dbKey, serializedClip, avatarActual).catch(() => {});
                    
                    console.log(`üì¶ Precargada: ${palabraNormalizada}`);
                    
                    // Liberar recursos AGRESIVO
                    if (gltf.scene) {
                        gltf.scene.traverse((child) => {
                            if (child.geometry) {
                                child.geometry.dispose();
                                child.geometry = null;
                            }
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(m => {
                                        m.dispose();
                                        for (const key in m) {
                                            if (m[key]?.dispose) m[key].dispose();
                                        }
                                    });
                                } else {
                                    child.material.dispose();
                                    for (const key in child.material) {
                                        if (child.material[key]?.dispose) child.material[key].dispose();
                                    }
                                }
                                child.material = null;
                            }
                        });
                        gltf.scene = null;
                    }
                }
            } catch (error) {
                // Ignorar errores de precarga silenciosa
            }
        }
        
        async function cargarYReproducirAnimacion(palabra, categoriaBackend = null, archivoBackend = null) {
            // Normalizar tildes antes de buscar en diccionario (mantiene √±)
            const palabraNormalizada = normalizarTextoEspanol(palabra.toLowerCase().trim());
            
            console.log(`üéØ cargarYReproducirAnimacion INICIO - palabra="${palabra}", normalizada="${palabraNormalizada}", avatarActual="${avatarActual}"`);
            logToExpo(`üéØ Procesando`, { palabra, normalizada: palabraNormalizada, avatar: avatarActual });
            
            // Si no viene del backend, buscar en diccionario local
            let categoria, archivo;
            if (categoriaBackend && archivoBackend) {
                // Usar datos del backend
                categoria = categoriaBackend;
                archivo = archivoBackend;
                console.log(`üåê Usando datos del backend para: ${palabra} (${categoria})`);
            } else if (DICCIONARIO[palabraNormalizada]) {
                // Buscar en diccionario local
                categoria = DICCIONARIO[palabraNormalizada].categoria;
                archivo = DICCIONARIO[palabraNormalizada].archivo;
                console.log(`üìñ Encontrado en diccionario: "${palabraNormalizada}" ‚Üí categoria="${categoria}", archivo="${archivo}"`);
                logToExpo(`üìñ Diccionario OK`, { palabra: palabraNormalizada, categoria, archivo });
            } else {
                // No hay datos disponibles
                console.warn(`‚ö†Ô∏è No se encontr√≥: ${palabra} (normalizada: ${palabraNormalizada})`);
                logToExpo(`‚ö†Ô∏è NO ENCONTRADO: ${palabraNormalizada}`);
                return;
            }
            
            // ‚≠ê SISTEMA DE CACH√â EFICIENTE
            // Paso 1: Buscar en cach√© RAM (instant√°neo)
            if (animationCache.has(palabraNormalizada)) {
                console.log(`‚ö° RAM cach√©: ${palabra}`);
                const clip = animationCache.get(palabraNormalizada);
                await reproducirAnimacion(clip, palabra);
                return;
            }
            
            // Paso 2: Buscar en IndexedDB (r√°pido)
            const dbKey = `${avatarActual}-${palabraNormalizada}`;
            const clipDataFromDB = await loadAnimationFromDB(dbKey);
            
            if (clipDataFromDB) {
                console.log(`üíæ IndexedDB: ${palabra}`);
                const clip = deserializeAnimationClip(clipDataFromDB);
                
                // Guardar en RAM para acceso m√°s r√°pido
                if (animationCache.size >= MAX_CACHE_SIZE) {
                    const firstKey = animationCache.keys().next().value;
                    animationCache.delete(firstKey);
                }
                animationCache.set(palabraNormalizada, clip);
                
                await reproducirAnimacion(clip, palabra);
                return;
            }
            
            // Paso 3: Descargar desde red (lento)
            console.log(`‚è≥ Descargando: ${palabra}`);
            logToExpo(`üì• Descargando: ${palabra}`);
            updateStatus(`üì• ${palabra}...`, true);
            
            // Reutilizar loader global
            const loader = loaderInstance || new GLTFLoader();
            
            return new Promise(async (resolve, reject) => {
                const timeout = isMobile ? 18000 : 25000; // Timeout muy generoso para primera carga
                const timeoutId = setTimeout(() => {
                    console.error(`‚è±Ô∏è Timeout: ${palabra}`);
                    logToExpo(`‚è±Ô∏è Timeout descargando: ${palabra}`);
                    resolve(); // Continuar con siguiente palabra
                }, timeout);
                
                try {
                    const { gltf, rutaCompleta } = await cargarGLBDesdeCarpetas(loader, categoria, archivo, avatarActual);
                    clearTimeout(timeoutId);
                    
                    if (gltf.animations && gltf.animations.length > 0) {
                        const clip = gltf.animations[0];
                        procesarTracksAnimacion(clip);
                        
                        // Guardar en RAM
                        if (animationCache.size >= MAX_CACHE_SIZE) {
                            const firstKey = animationCache.keys().next().value;
                            animationCache.delete(firstKey);
                        }
                        animationCache.set(palabraNormalizada, clip);
                        
                        // Guardar en IndexedDB para pr√≥xima vez (as√≠ncrono, no bloquea)
                        const serializedClip = serializeAnimationClip(clip);
                        saveAnimationToDB(dbKey, serializedClip, avatarActual).catch(err => {
                            console.warn('‚ö†Ô∏è No se pudo guardar en IndexedDB:', err);
                        });
                        
                        console.log(`‚úÖ ${palabra} (${clip.duration.toFixed(2)}s) RAM:${animationCache.size}/${MAX_CACHE_SIZE}`);
                        logToExpo(`‚úÖ Animaci√≥n lista: ${palabra}`);
                        
                        await reproducirAnimacion(clip, palabra);
                        
                        // Liberar memoria de geometr√≠as del GLB (AGRESIVO)
                        if (gltf.scene) {
                            gltf.scene.traverse((child) => {
                                if (child.geometry) {
                                    child.geometry.dispose();
                                    child.geometry = null;
                                }
                                if (child.material) {
                                    if (Array.isArray(child.material)) {
                                        child.material.forEach(m => {
                                            m.dispose();
                                            for (const key in m) {
                                                if (m[key]?.dispose) m[key].dispose();
                                            }
                                        });
                                    } else {
                                        child.material.dispose();
                                        for (const key in child.material) {
                                            if (child.material[key]?.dispose) child.material[key].dispose();
                                        }
                                    }
                                    child.material = null;
                                }
                            });
                            // Limpiar referencia
                            gltf.scene = null;
                        }
                        
                        resolve();
                    } else {
                        console.warn(`‚ö†Ô∏è Sin animaciones: ${palabra}`);
                        resolve();
                    }
                } catch (error) {
                    clearTimeout(timeoutId);
                    console.error(`‚ùå Error: ${palabra}`, error);
                    logToExpo(`‚ùå Error cargando: ${palabra}`);
                    resolve(); // Continuar incluso si falla
                }
            });
        }
        
        // Nueva funci√≥n para procesar tracks una sola vez
        function procesarTracksAnimacion(clip) {
            // Verificar si hay tracks de morph targets
            const morphTracks = clip.tracks.filter(t => t.name.includes('.morphTargetInfluences'));
            if (morphTracks.length > 0) {
                console.log(`üé≠ Animaci√≥n con ${morphTracks.length} tracks de morph targets`);
            }
            
            // Corregir nombres de tracks si hay mapping
            if (avatarModel && avatarModel.userData.nodeNameMap) {
                clip.tracks.forEach((track, index) => {
                    const trackNodeName = track.name.split('.')[0];
                    const mappedName = avatarModel.userData.nodeNameMap[trackNodeName];
                    
                    if (mappedName) {
                        const newTrackName = track.name.replace(trackNodeName, mappedName);
                        track.name = newTrackName;
                    }
                });
            }
        }
        async function reproducirAnimacion(clip, palabra) {
            return new Promise((resolve) => {
                // Peque√±a pausa para estabilizar (especialmente importante en primera reproducci√≥n)
                setTimeout(() => {
                    // Detener animaci√≥n actual SIN transici√≥n para fluidez
                    if (currentAction) {
                        currentAction.stop();
                    }
                    
                    // Reproducir nueva animaci√≥n inmediatamente
                    const action = mixer.clipAction(clip);
                    action.reset();
                    action.setLoop(THREE.LoopOnce);
                    action.clampWhenFinished = true;
                    action.play();
                    
                    currentAction = action;
                    
                    const onFinished = (e) => {
                        if (e.action === action) {
                            console.log(`‚úÖ Completada: ${palabra}`);
                            mixer.removeEventListener('finished', onFinished);
                            // Peque√±a pausa entre animaciones para suavidad
                            setTimeout(resolve, isMobile ? 50 : 30);
                        }
                    };
                    mixer.addEventListener('finished', onFinished);
                }, isMobile ? 100 : 50); // Pausa antes de reproducir
            });
        }
        
        // Nueva funci√≥n: Precargar animaciones m√°s comunes en background
        async function precargarAnimacionesComunes() {
            // En m√≥vil, precargar menos animaciones (o ninguna si lazy loading est√° activo)
            const animacionesComunes = isMobile 
                ? [] // M√≥vil: lazy loading puro, sin precarga
                : ['hola', 'buenos dias', 'gracias', 'por favor', 'adios', 'si', 'no', 'bien', 'mal', 'mucho gusto'];
            
            if (animacionesComunes.length === 0) {
                console.log('üì± Precarga desactivada (lazy loading)');
                return;
            }
            
            console.log('üîÑ Iniciando precarga de animaciones comunes...');
            
            for (const palabra of animacionesComunes) {
                if (animationCache.has(palabra)) continue;
                
                const palabraNormalizada = normalizarTextoEspanol(palabra.toLowerCase().trim());
                if (!DICCIONARIO[palabraNormalizada]) continue;
                
                // Verificar primero en IndexedDB
                const dbKey = `${avatarActual}-${palabraNormalizada}`;
                const clipDataFromDB = await loadAnimationFromDB(dbKey);
                
                if (clipDataFromDB) {
                    const clip = deserializeAnimationClip(clipDataFromDB);
                    animationCache.set(palabraNormalizada, clip);
                    console.log(`‚úÖ Precargada desde DB: ${palabra}`);
                    continue;
                }
                
                // Si no est√° en DB, descargar
                try {
                    const loader = loaderInstance || new GLTFLoader();
                    const { categoria, archivo } = DICCIONARIO[palabraNormalizada];
                    const { gltf } = await cargarGLBDesdeCarpetas(loader, categoria, archivo, avatarActual);
                    
                    if (gltf.animations && gltf.animations.length > 0) {
                        const clip = gltf.animations[0];
                        procesarTracksAnimacion(clip);
                        animationCache.set(palabraNormalizada, clip);
                        
                        // Guardar en IndexedDB
                        const serializedClip = serializeAnimationClip(clip);
                        saveAnimationToDB(dbKey, serializedClip, avatarActual).catch(() => {});
                        
                        console.log(`‚úÖ Precargada: ${palabra}`);
                        
                        // Liberar recursos AGRESIVO
                        if (gltf.scene) {
                            gltf.scene.traverse((child) => {
                                if (child.geometry) {
                                    child.geometry.dispose();
                                    child.geometry = null;
                                }
                                if (child.material) {
                                    if (Array.isArray(child.material)) {
                                        child.material.forEach(m => {
                                            m.dispose();
                                            for (const key in m) {
                                                if (m[key]?.dispose) m[key].dispose();
                                            }
                                        });
                                    } else {
                                        child.material.dispose();
                                        for (const key in child.material) {
                                            if (child.material[key]?.dispose) child.material[key].dispose();
                                        }
                                    }
                                    child.material = null;
                                }
                            });
                            gltf.scene = null;
                        }
                    }
                    
                    // Pausa adaptativa
                    await new Promise(r => setTimeout(r, LOAD_DELAY));
                    
                } catch (error) {
                    console.log(`‚ö†Ô∏è No se pudo precargar: ${palabra}`);
                }
            }
            
            console.log(`‚úÖ Precarga completada: ${animationCache.size} animaciones en cach√©`);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            if (mixer && !isPaused) {
                mixer.update(delta);
                
                // Asegurar que los morph targets se actualicen
                if (avatarModel) {
                    avatarModel.traverse((child) => {
                        if (child.isMesh && child.morphTargetInfluences) {
                            // El material ya deber√≠a estar configurado, pero forzar update si es necesario
                            if (child.material && !child.material.morphTargets) {
                                child.material.morphTargets = true;
                                child.material.needsUpdate = true;
                            }
                        }
                    });
                }
            }
            
            controls.update();
            renderer.render(scene, camera);
        }

        // Detectar eventos de focus/blur que tambi√©n indican teclado virtual
        window.addEventListener('focusin', () => {
            logToExpo('üîç FOCUSIN detectado');
            if (isMobile && camera && controls && !savedCameraState) {
                savedCameraState = {
                    position: camera.position.clone(),
                    target: controls.target.clone(),
                    zoom: camera.zoom,
                    fov: camera.fov
                };
                logToExpo('üî¥ Input enfocado - estado guardado:', {
                    position: { x: savedCameraState.position.x, y: savedCameraState.position.y, z: savedCameraState.position.z },
                    target: { x: savedCameraState.target.x, y: savedCameraState.target.y, z: savedCameraState.target.z }
                });
                
                // CONGELAR OrbitControls
                controls.enabled = false;
                logToExpo('‚õî OrbitControls DESHABILITADO (focusin)');
            }
        });
        
        window.addEventListener('focusout', (e) => {
            // Solo actuar si el foco sale completamente del documento (teclado cerrado)
            setTimeout(() => {
                const activeElement = document.activeElement;
                const isInputActive = activeElement && activeElement.tagName === 'INPUT';
                
                logToExpo('üîì FOCUSOUT detectado', { 
                    isMobile, 
                    hasSavedState: !!savedCameraState,
                    isInputStillActive: isInputActive,
                    activeElement: activeElement ? activeElement.tagName : 'none'
                });
                
                // Solo restaurar si el input ya NO est√° activo (teclado realmente cerrado)
                if (isMobile && savedCameraState && !isInputActive) {
                    logToExpo('‚è∞ Ejecutando restauraci√≥n con resetCamera()');
                    
                    // Usar la funci√≥n resetCamera() que ya existe
                    resetCamera();
                    
                    // Limpiar estado guardado
                    savedCameraState = null;
                    logToExpo('‚úÖ Estado limpiado');
                } else {
                    logToExpo('‚ö†Ô∏è No se restaura:', { 
                        razon: !isMobile ? 'No es m√≥vil' : (!savedCameraState ? 'No hay estado guardado' : 'Input a√∫n activo')
                    });
                }
            }, 100); // Peque√±o delay para que activeElement se actualice
        });

        // Listener para mensajes de React Native WebView
        window.addEventListener('message', function(event) {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'changeAvatar' && data.avatar) {
                    console.log('üì± Mensaje recibido: cambiar a avatar', data.avatar);
                    cargarAvatar(data.avatar);
                }
            } catch (e) {
                // Ignorar mensajes mal formados
            }
        });

        // Listener adicional para Android
        document.addEventListener('message', function(event) {
            try {
                const data = JSON.parse(event.data);
                if (data.type === 'changeAvatar' && data.avatar) {
                    console.log('üì± Mensaje recibido (Android): cambiar a avatar', data.avatar);
                    cargarAvatar(data.avatar);
                }
            } catch (e) {
                // Ignorar mensajes mal formados
            }
        });

        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
